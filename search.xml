<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HashMap(一)</title>
      <link href="/sunshine-carroll.github.io/2020/11/25/HashMap-%E4%B8%80/"/>
      <url>/sunshine-carroll.github.io/2020/11/25/HashMap-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>– 参考自算法导论第11章散列表</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>在编写Java程序时，通常都会直接或者间接的用到Java提供容器类库如Collection,List,Set,Map等。HashMap是Java容器类库中的一员，其实现了Map接口。在提供Map接口定义的功能的同时，HashMap使用了散列寻址技术让程序使用HashMap时可以快速的搜索元素。过早的看源码容易迷失在源代码中，这篇博客先撇开具体的Java，介绍一些直接寻址，散列寻址的内容。由于水平有限，如有错误之处，欢迎评论。</p><blockquote><p>🍀 这篇博客不会解释链表，红黑树的具体结构和原理，这不是本文的主旨，也不影响阅读。只需要知道链表和红黑树都可以提供基本的插入,搜索,删除操作就👌</p></blockquote><h2 id="直接寻址表"><a href="#直接寻址表" class="headerlink" title="直接寻址表"></a>直接寻址表</h2><p>虽然在HashMap使用了散列寻址技术，但在介绍散列表之前，先了解下直接寻址表。对比直接寻址表和散列表，会更明白为什么在某些情况下要用散列寻址。直接寻址表是一种非常简单快速的动态集合结构</p><p>直接寻址表和散列表都支持一些动态集合操作 insert,delete,search。假如说我们有这样一个动态集合S,$S ⊆ U$,其中$U={1,2,\cdots m-1}$是全域S的每个元素都取自全域中的一个关键字。直接寻址表可以表示为一个数组。$T[0..m-1]$,数组中每个位置称为槽。如果槽k要么指向全域中关键字为k的一个元素，要么指向NIL(表示空同null)。然后我们就可以写出直接寻址表的insert,delete,search</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">procedure direct-address-search(T,k)</span><br><span class="line">return T[k];</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">procedure direct-address-insert(T,x)</span><br><span class="line">T[x.key] &#x3D; x</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">procedure direct-address-delete(T,x)</span><br><span class="line">T[x.key] &#x3D; NIL</span><br></pre></td></tr></table></figure><p>上面三个操作的时间复杂度都是$O(1)$。直接寻址表的一个特点就是表的大小等于动态集合的全域的大小，在$｜U｜$较小的时候，能够简洁简单的提供insert,delete,search操作。但当全域U较大时，直接寻址表的劣势就非常明显,使用直接寻址表，表的大小必须和全域一样,这计算机可能没有这么大的内存或者不应该用这么大的内存，而且动态集合中出现的元素可能远小于全域的大小，会造成空间的浪费。这个时候散列表就能应对全域比较大的动态集合。</p><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>使用直接寻址方式时，具有关键字k的元素被放在T[k]中，但在散列寻址方式下，具有关键字k的元素被存放在T[h(k)]中,h时下面一个散列函数<br>$$<br>h:U → (1,2,\cdots,m-1)<br>$$<br>这个散列函数将全域U映射到散列表$T[0..m-1]$上。但是散列表也有问题，假设有两个关键字$k_1,k_2,h(k_1)=h(k_2)$这个时候带有关键字$k_1,k_2$的元素就不知到该放在哪了。解决散列冲突的方法有很多种，有链接法和开放寻址法等，关于开发寻址法，这个不是这篇博客的目的，可以参考算法导论11.4。Java之前使用链接法解决散列冲突，散列值一样的关键字代表的元素会存放在同一个链表中。Java8 之后，在满足一定条件时，散列值一样的关键字所代表的元素会存放在红黑树之中。</p><h3 id="链接法解决冲突的伪代码"><a href="#链接法解决冲突的伪代码" class="headerlink" title="链接法解决冲突的伪代码"></a>链接法解决冲突的伪代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">procedure chained-address-search(T,k)</span><br><span class="line">return search element from list T[h(k)] with key k;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">procedure chained-address-insert(T,x)</span><br><span class="line">insert at head of list T[h(x.key)]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">procedure chained-address-delete(T,x)</span><br><span class="line">delete x from  list T[h(x.key)]</span><br></pre></td></tr></table></figure><p>插入时，只需要根据元素x的关键字的散列值找到相应的链表，然后插入到表头就可以了，搜索也是同样的方式找到链表然后在链表中搜索元素x。删除时算法导论建议使用双链表，这样元素x的删除只需要$O(1)$的时间复杂度，但是实现有时候并不完全按照算法所建议的来。HashMap使用了单链表作为散列表的槽。</p><h3 id="散列表的负载因子-load-factor"><a href="#散列表的负载因子-load-factor" class="headerlink" title="散列表的负载因子(load factor)"></a>散列表的负载因子(load factor)</h3><p>散列表有一个衡量指标叫负载因子，假设有一个存放着n个元素，大小为m的散列表T，T的负载因子$\alpha = \frac{n}{m}$</p><p>链接法解决冲突的散列表查找性能的最坏情形是所有动态集合中的元素被散列到了一个槽中这个时候就相当于在链表中查询一个元素的速度，链表查找元素的时间复杂度为$O(n)$</p><p>两个有用的定理能够表示负载因子对散列表性能的影响，先解释一下这里假设散列函数是$O(1)$的，简单均匀散列是指给定任意一个元素，该元素能够等可能的散列在m个槽中的任意一个。</p><blockquote><p>在简单均匀散列的情况下，使用链接法解决冲突的散列表，一次成功查找所需的平均时间为$\Theta(1+\alpha)$</p><p>在简单均匀散列的情况下，使用链接法解决冲突的散列表，失败成功查找所需的平均时间为$\Theta(1+\alpha)$</p></blockquote><blockquote><p>🍀 比较直接寻址表和散列表时，有两个因素，$\frac{动态集合大小}{全域大小}和全域大小$ 当动态集合的大小接近全域的大小时，散列表的实际存储开销会比直接寻址表大(由于不同的存储结构)。散列表可以一开始选用合适的大小，然后在动态集合中元素过多时合理增加散列表的大小，然后对动态集合中的元素再散列。</p></blockquote><h3 id="使用红黑树"><a href="#使用红黑树" class="headerlink" title="使用红黑树"></a>使用红黑树</h3><p>就如上所说，链接法解决冲突的散列表最坏情形复杂度相当于在链表中查找,其时间复杂度为$O(n)$。最坏情形，就是所以元素散列到一个槽中，这个时候的查询性能依赖于槽的结构。为了让最坏情形下散列表也能有较好的性能，可以选择合适槽的结构。HashMap选择在满足一定条件时将槽从链表转变为红黑树。红黑树在最坏情形下，也能保证动态集合的基本操作的时间复杂度为$O(lg\ n)$, HashMap中的散列表槽可能是链表也可能是红黑树，这篇博客不描述混和的情况。下面描述完全使用红黑树解决冲突的散列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">procedure chained-address-search(T,k)</span><br><span class="line">return search element from red-black-tree T[h(k)] with key k;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">procedure chained-address-insert(T,x)</span><br><span class="line">insert at head of red-black-tree T[h(x.key)]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">procedure chained-address-delete(T,x)</span><br><span class="line">delete x from  red-black-tree T[h(x.key)]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> collections </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="/sunshine-carroll.github.io/2020/11/17/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>/sunshine-carroll.github.io/2020/11/17/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>红黑树是一种二叉搜索树，它在每个结点上加上一个存储位表示树的颜色红或者黑。虽然随机构建二叉搜索树的期望高度是$O(lgn)$，二叉搜索的基本操作search,insert,delete,predecessor,successor,maximum,minimum 的运行时间是$O(h)$（h是树高），但是二叉搜索树并不一定总是随机构建的，而且随着插入和删除，树高的变化复杂。在最坏情形下，二叉搜索树的查找的时间复杂度和链表的一样。红黑树可以保证在最话情形下基本动态集合操作的时间复杂度是$O(lgn)$</p><h2 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h2><h3 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h3><p>红黑树的结点除了left，right,p,key四个属性之外，还有第五个属性color，它可以是red,或者black。如果一个结点没有子结点，或者父结点，那么结点指针属性的值为NIL。这里把NIL看作红黑树的叶子结点,把带有key的结点看作红黑树的内部结点。</p><h3 id="红黑性质"><a href="#红黑性质" class="headerlink" title="红黑性质"></a>红黑性质</h3><ol><li>每个结点或者是红色或者是黑色，没有其他颜色</li><li>根结点是黑色的</li><li>叶子结点是黑色的</li><li>如果一个结点是红色的，那么该结点的两个子结点是黑色的</li><li>对于每个结点，该结点到后代叶子结点的每一条简单路径均有相同的黑色结点</li></ol><blockquote><p>🍀 算法导论中定义T.nil，表示公用的叶子结点，因为红黑树叶子结点除了其color属性，其余属性都不重要。类似面向对象语言中的惯用法，定义空对象来代替null。</p></blockquote><h3 id="黑高"><a href="#黑高" class="headerlink" title="黑高"></a>黑高</h3><blockquote><p>从某个结点出发(不包含该结点),到叶子结点的任意一条简单路径上的黑色结点数。由于红黑树的性质，对于每个结点，该结点到后代叶子结点的每一条简单路径均有相同的黑色结点。所以一个结点的黑高时确定的，红黑树的黑高定义为根结点的黑高</p></blockquote><h3 id="引理1"><a href="#引理1" class="headerlink" title="引理1"></a>引理1</h3><blockquote><p>一颗具有n个结点的红黑树，其高度最多为2lg(n+1)。 </p></blockquote><p>证明：</p><p>先证明任意一颗以x为根的子树至少包含$2^{bh(x)}-1$个内部结点。这里用p表示内部结点树</p><p>基础步骤: x是叶子结点(NIL)的时候，$bh(x) = 0,p=0 .\  y&lt;=2^0-1成立$</p><p>归纳步骤: 如果$x_1,x_2$是红黑树子树的根结点,x是$x_1,x_2$的父结点 $p_1 &lt;= 2^{bh(x_1)}-1$,,$p_2 &lt;= 2^{bh(x_2)}-1$</p><p>根结点的黑高为$bh(x)$，x每个子结点的黑高为$bh(x)$(当该子结点为红)或者$bh(x)-1$(当该子结点为黑)<br>$$<br>\begin{align}<br>p&amp;=p_1+p_2+1\<br>&amp;≤2^{bh(x_1)}-1 + 2^{bh(x_2)}-1+1 \<br>&amp;≤2^{bh(x)-1}-1+2^{bh(x)-1}-1+1 \tag{这步也没看懂，后面看}\<br>&amp;=2^{bh(x)}-1<br>\end{align}<br>$$<br>所以任意一颗以x为根的子树至少包含$2^{bh(x)}-1$个内部结点</p><p>根据性质4，如果一个结点为红，那么该结点的两个子结点为黑。考虑红黑树从根结点到叶子结点的任意一条简单路径，根结点，叶子结点必定为黑色，如果该简单路径有n个红色结点，那么至少有n个黑色结点。所以红黑树的树高$h≤2bh(x)$</p><p>所以<br>$$<br>\begin{align}<br>n&amp;≥2^{h/2}-1\<br>h&amp;≤2lg(n+1)<br>\end{align}<br>$$</p><h2 id="二叉搜索树的旋转"><a href="#二叉搜索树的旋转" class="headerlink" title="二叉搜索树的旋转"></a>二叉搜索树的旋转</h2><p>下面描述能够保持二叉搜索树性质的局部操作，左旋和右旋。<br></p><p>下图是左旋右旋的转化图，左旋的时候其中$\alpha,\beta,\gamma$是任意子树，x,y为二叉搜索树中的结点，x可以为二叉搜索树中任意右孩子不为NIL的结点(如果x的右孩子是NIL,那么旋转后，y成为x的父结点，违反二叉搜索树的基本性质)，右旋的时候，y应该是二叉搜索树中任意一个左孩子不为NIL的结点</p><p><img src="/sunshine-carroll.github.io/2020/11/17/%E7%BA%A2%E9%BB%91%E6%A0%91/rotate.png" alt="rotate"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">procedure left-rotate(T,x)</span><br><span class="line">y &#x3D; x.right </span><br><span class="line">x.right &#x3D; y.left </span><br><span class="line">if y.left !&#x3D; NIL </span><br><span class="line">y.left.p &#x3D;  x</span><br><span class="line">y.p &#x3D; x.p</span><br><span class="line">if x.p &#x3D;&#x3D; NIL </span><br><span class="line">T.root &#x3D; y</span><br><span class="line">else if x &#x3D;&#x3D; x.p.left</span><br><span class="line">x.p.left &#x3D; y</span><br><span class="line">else</span><br><span class="line">x.p.right &#x3D; y</span><br><span class="line">x.p &#x3D; y</span><br><span class="line">y.left &#x3D; x</span><br></pre></td></tr></table></figure><p>第2行 找到x的右结点y 。第3～5行处理beta，首先修改x的右结点为beta,然后根据beta是不是NIL,处理是否修改beta的父结点。第6行处理y的父结点。第7到12行根据x与x.p的关系做相应处理，最后两行分别修改x的父结点为y,y的左子树为x</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">procedure right-rotate(T,y)</span><br><span class="line">x &#x3D; y.left</span><br><span class="line">y.left &#x3D; x.right</span><br><span class="line">if x.right !&#x3D; NIL</span><br><span class="line">x.right.p &#x3D; y</span><br><span class="line">x.p &#x3D; y.p</span><br><span class="line">if y.p &#x3D; NIL</span><br><span class="line">T.root &#x3D; x</span><br><span class="line">else if y &#x3D;&#x3D; y.p.left</span><br><span class="line">y.p.left &#x3D; x</span><br><span class="line">else </span><br><span class="line">y.p.right &#x3D; y</span><br><span class="line">y.p &#x3D; x</span><br><span class="line">x.left &#x3D; y</span><br></pre></td></tr></table></figure><h2 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">procedure rb-insert(T,z)</span><br><span class="line">y &#x3D; NIL</span><br><span class="line">x &#x3D; T.root</span><br><span class="line">while x !&#x3D; NIL</span><br><span class="line">y &#x3D; x</span><br><span class="line">if z.key ≤ x.key</span><br><span class="line">x &#x3D; x.left</span><br><span class="line">else</span><br><span class="line">x &#x3D; x.right</span><br><span class="line">if y &#x3D; NIL</span><br><span class="line">T.root &#x3D; z</span><br><span class="line">else if z.key &lt; y.key</span><br><span class="line">y.left &#x3D; z</span><br><span class="line">else</span><br><span class="line">y.right &#x3D; z</span><br><span class="line">z.left &#x3D; NIL</span><br><span class="line">z.right &#x3D; NIL</span><br><span class="line">z.color &#x3D; red</span><br><span class="line">rb-insert-fixup(T,z)</span><br></pre></td></tr></table></figure><h2 id="插入结点时红黑性质的维护"><a href="#插入结点时红黑性质的维护" class="headerlink" title="插入结点时红黑性质的维护"></a>插入结点时红黑性质的维护</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">procedure rb-insert-fixup(T,z)</span><br><span class="line">while z.p.color &#x3D;&#x3D; red</span><br><span class="line">if z.p &#x3D; z.p.p.left</span><br><span class="line">y &#x3D; y.p.p.right</span><br><span class="line">if y.color &#x3D;&#x3D; red</span><br><span class="line">z.p.color &#x3D; black</span><br><span class="line">y.color &#x3D; black</span><br><span class="line">z.p.p.color &#x3D; red</span><br><span class="line">z &#x3D; z.p.p</span><br><span class="line">else </span><br><span class="line">if z &#x3D; z.p.right</span><br><span class="line">z &#x3D; z.p</span><br><span class="line">left-rotate(T,z)</span><br><span class="line">z.p.color &#x3D; black</span><br><span class="line">z.p.p.color &#x3D; red</span><br><span class="line">right-rotate(T,z.p.p)</span><br><span class="line">else</span><br><span class="line">y &#x3D; z.p.p.left</span><br><span class="line">if y.color &#x3D;&#x3D; red</span><br><span class="line">z.p.color &#x3D; black</span><br><span class="line">y.color &#x3D; black</span><br><span class="line">z.p.p.color &#x3D;  red</span><br><span class="line">z &#x3D; z.p.p</span><br><span class="line">else </span><br><span class="line">if z &#x3D; z.p.left </span><br><span class="line"> z &#x3D; z.p</span><br><span class="line"> right-rotate(T,z)</span><br><span class="line">      z.p.color &#x3D; black</span><br><span class="line">      z.p.p.color &#x3D; red</span><br><span class="line">      left-rotate(T,z.p.p)</span><br><span class="line">T.root.color &#x3D; black</span><br></pre></td></tr></table></figure><p>证明 $rb-insert-fixup(T,z)$ 在每次循环之前都满足下面三个循环不变式，并且循环结束后，树T保持红黑性质</p><ul><li>结点z时红色的              $(1)$</li><li>如果z.p是根结点，那么z.p是黑色的         $(2)$</li><li>如果有任何红黑性质被破坏，则做多只有一条被破坏，或者是性质2.或者是性质4。性质2被破坏的原因是，z是根结点且是红色结点，如果性质4被破坏那么是因为z，z.p都是红色的 。         $(3)$</li></ul><blockquote><p>🍀 由于整个插入算法不会插入非红黑色之外的结点，叶子结点是NIL黑色的，性质1，3显然成立</p></blockquote><p>证明</p><p>证明循环不变式为真可以分两步，一是证明循环开始前，循环不变式为真，执行s之后，循环不变式为真。</p><ul><li><p>开始前</p><p>在调用新插入的结点总是红色的。条件$(1)$成立</p><p>如果z.p为根，由于在调用$rb-insert-fixup(T,z)$ 之前，z.p是不变的，所以条件$(2)$成立</p><p>如果红黑树的性质2 根结点是黑色的 被违反，那么只可能是因为插入的红色结点z是根结点。这个时候</p><p>如果违反了性质4，由于z结点的左右子结点都是NIL黑色的，那么只可能是z.p是红色的。</p><p>插入红色结点不会改变任意路径的黑高，所以性质5是成立的</p><p>所以条件$(3)$成立</p></li><li><p>循环结束后</p><p>循环在z.p.color == black 时终止，此时不可能是性质4被破坏，那么被破坏的性质只能是性质2，算法的最后修复这个问题。</p><p>所以在循环结束后树T维护红黑性质</p></li><li><p>循环执行时:</p><p>这里可以分6中情况，按照z的父结点是祖父结点的左结点还是右结点可以分为两类对称3中情况。算法导论讨论了z的父结点是祖父结点的左孩子。这里讨论z的父结点是祖父结点的右孩子，当然没有算法导论完美，导论的图更全，建议看算法导论。</p><ul><li>当z的叔结点y(也就是z.p的兄弟结点)为红色时，将z.p和y都着色为黑色，并把祖父接点着色为红维护性质5(祖父结点必定是黑色的否则就违反性质4)，然后z指向z.p.p进行下一次迭代</li><li>当z的叔结点为黑色,且z是父结点的左结点，对z.p进行一次右旋(这个操作不会多违反一个性质)变成下面一种情况</li><li>当z的叔结点为黑色，且z时父结点的右结点，将z.p着色为黑色，讲z.p.p着色为红色，然后对z.p.p做一次左旋</li></ul></li></ul><blockquote><p>🍀 假设有下述一段程序，循环不变式是指每次执行程序段S时都保持为真的断言。或者说如果霍尔三元组$(p \and condition){s}p$为真时，那么这里$p$就是下述程序段的循环不变式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while condition</span><br><span class="line">S</span><br></pre></td></tr></table></figure></blockquote><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2>]]></content>
      
      
      <categories>
          
          <category> data structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树</title>
      <link href="/sunshine-carroll.github.io/2020/11/16/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/sunshine-carroll.github.io/2020/11/16/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>二叉搜索树是一种二叉树，他的结点除了key和卫星数据之外，还包括left,right,p,分别指向结点的左子树，右子树和父结点，如果子树或者父结点不存在，那么对应的属性为NIL。根节点是唯一一个父节点为NIL的结点。</p><p>二叉搜索树的任意动态集合操作 search,insert,delete,maximum,minimum,successor,predecessor的时间复杂度都为$O(h)$</p><p>一颗具有n个不同关键字随机构建的二叉搜索树的期望高度为O(lg n)。关键字集合的每一个生成排列出现的概率都是等可能性的</p><h2 id="二叉搜索树的关键词存储"><a href="#二叉搜索树的关键词存储" class="headerlink" title="二叉搜索树的关键词存储"></a>二叉搜索树的关键词存储</h2><p>假设x是二叉搜索树中的一个结点，如果y是x左子树的一个结点，那么y.key &lt;= x.key,如果y是x的右子树的一个结点，那么<br>y.key&gt;=x.key</p><h2 id="二叉搜索树T的一些性质"><a href="#二叉搜索树T的一些性质" class="headerlink" title="二叉搜索树T的一些性质"></a>二叉搜索树T的一些性质</h2><ul><li>$h ≥ \lfloor n \rfloor$ h是T的高度，n是结点数</li></ul><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>二叉搜索树m=2的有序根树</p><p>二叉搜索树的中序遍历定义为: 假设T 是以r为根的二叉搜索树，如果T只含树根r，那么r是T的一个中序遍历。否则设$T_1,T_2$是从左到右的子树，中序遍历$T_1$再访问r,然后中序遍历$T_2$。下面是二叉搜索树中序遍历的伪代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">procedure inorder-tree-work(x)</span><br><span class="line">if x !&#x3D; NIL</span><br><span class="line">inorder-tree-work(x.left)</span><br><span class="line">print(x.key)</span><br><span class="line">inorder-tree-work(x.right)</span><br></pre></td></tr></table></figure><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="递归版本"><a href="#递归版本" class="headerlink" title="递归版本"></a>递归版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">procedure tree-search(x,k)</span><br><span class="line">if x !&#x3D; NIL or k &#x3D; x.key</span><br><span class="line">return x</span><br><span class="line">if k &lt; x.key </span><br><span class="line">return tree-search(x.left,k)</span><br><span class="line">return tree-search(x.right,k)</span><br></pre></td></tr></table></figure><h3 id="迭代版本"><a href="#迭代版本" class="headerlink" title="迭代版本"></a>迭代版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">procedure iterative-tree-search(x,k)</span><br><span class="line">while x !&#x3D; NIL and k !&#x3D; x.key</span><br><span class="line">if k &lt; x.key</span><br><span class="line">x &#x3D; x.left</span><br><span class="line">else</span><br><span class="line">x &#x3D; x.right</span><br><span class="line">return x</span><br></pre></td></tr></table></figure><h2 id="最小值"><a href="#最小值" class="headerlink" title="最小值"></a>最小值</h2><p>###迭代版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">procedure iterative-tree-minimum(x)</span><br><span class="line">while x.left !&#x3D; NIL</span><br><span class="line">x &#x3D; x.left</span><br><span class="line">return x</span><br></pre></td></tr></table></figure><h3 id="递归版本-1"><a href="#递归版本-1" class="headerlink" title="递归版本"></a>递归版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">procedure tree-minimum(x)</span><br><span class="line">if x.left &#x3D; NIL</span><br><span class="line">return x</span><br><span class="line">else</span><br><span class="line">return tree-minimum(x.left)</span><br></pre></td></tr></table></figure><h2 id="最大值"><a href="#最大值" class="headerlink" title="最大值"></a>最大值</h2><h3 id="迭代版本-1"><a href="#迭代版本-1" class="headerlink" title="迭代版本"></a>迭代版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">procedure iterative-tree-maximum(x)</span><br><span class="line">while x.right !&#x3D; NIL</span><br><span class="line">x &#x3D; x.right</span><br><span class="line">return x</span><br></pre></td></tr></table></figure><h3 id="递归版本-2"><a href="#递归版本-2" class="headerlink" title="递归版本"></a>递归版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">procedure tree-maximum(x)</span><br><span class="line">if x.right &#x3D; NIL</span><br><span class="line">return x</span><br><span class="line">else</span><br><span class="line">return tree-right(x.left)</span><br></pre></td></tr></table></figure><h2 id="后继"><a href="#后继" class="headerlink" title="后继"></a>后继</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">procedure successor(x)</span><br><span class="line">if x.right !&#x3D; NIL</span><br><span class="line">return tree-mininum(x)</span><br><span class="line">y &#x3D; x.p</span><br><span class="line">while y !&#x3D; NIL and x &#x3D;&#x3D; y.right</span><br><span class="line">x &#x3D; y</span><br><span class="line">y &#x3D; y.p</span><br><span class="line">return y</span><br></pre></td></tr></table></figure><h2 id="前驱"><a href="#前驱" class="headerlink" title="前驱"></a>前驱</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">procedure predecessor(x)</span><br><span class="line">if x.left !&#x3D; NIL</span><br><span class="line">return tree-maximum(x)</span><br><span class="line">y &#x3D; x.p</span><br><span class="line">while y !&#x3D; NIL and x &#x3D;&#x3D; y.left</span><br><span class="line"> x &#x3D; y</span><br><span class="line"> y &#x3D;&#x3D; y.p</span><br><span class="line">return y</span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">procedure tree-insert(T,z)</span><br><span class="line">x &#x3D; T.root &#x2F;&#x2F; 迭代指针</span><br><span class="line">y &#x3D; NIL &#x2F;&#x2F;迭代后，y是z的父节点</span><br><span class="line">while x !&#x3D; NIL</span><br><span class="line">y &#x3D; x </span><br><span class="line">if z.key &lt; x.key</span><br><span class="line">x &#x3D; x.left</span><br><span class="line">else</span><br><span class="line">x &#x3D; x.right</span><br><span class="line">z.p &#x3D; y</span><br><span class="line"> if y &#x3D; NIL</span><br><span class="line"> T.root &#x3D; z</span><br><span class="line"> else if z.key &lt; x.key</span><br><span class="line"> y.left &#x3D; z</span><br><span class="line"> else</span><br><span class="line"> y.right &#x3D; z</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>从二叉搜索树中删除一个结点z有三种情况</p><ul><li>如果z没有孩子结点，那么直接删除删除该结点，然后修改父结点对应的孩子结点为NIL</li><li>只有一个孩子，将这个孩子提升到z，并修改父结点对应的孩子为z的孩子</li><li>有两个孩子，找到z的后继y(由于存在两个孩子，后继必在z的右子树中)，，z的左子树成为y的左子树，关于右子树有两种情况<ul><li>y是z的右孩子，y代替z后，保留y的右子树</li><li>y不是z的右孩子，由于y是z的后继，先删除y(y必定没有左孩子，删除y属于第二种情况),让y代替树中z的位置，z的右子树成为y的右子树</li></ul></li></ul><p>下面是删除二叉搜索树的结点算法的子过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">procedure transplant(T,u,v) &#x2F;&#x2F; T 是二叉搜索树，u，v是T中的结点，u是被替代的结点，v是替代u的结点</span><br><span class="line">if u.p &#x3D;&#x3D; NIL &#x2F;&#x2F; 处理u是root的情况</span><br><span class="line">T.root &#x3D; v</span><br><span class="line">else if u &#x3D;&#x3D; u.p.left </span><br><span class="line">u.p.left &#x3D; v</span><br><span class="line">else</span><br><span class="line">u.p.right &#x3D; b</span><br><span class="line">if v !&#x3D; NIL &#x2F;&#x2F;如果移植的树v不是NIL,那么需要更新v.p</span><br><span class="line">v.p &#x3D; u.p</span><br></pre></td></tr></table></figure><p>delete</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">procedure tree-delete(T,z)</span><br><span class="line">if z.left &#x3D;&#x3D; NIL</span><br><span class="line">transplant(T,z,z.right)</span><br><span class="line">else if z.right &#x3D;&#x3D; NIL</span><br><span class="line">transplant(T,z,z.left)</span><br><span class="line">else </span><br><span class="line">y &#x3D; tree-minimum(z)</span><br><span class="line">if y.p !&#x3D; z</span><br><span class="line">transplant(T,y,y.right)</span><br><span class="line">y.right &#x3D; z.right</span><br><span class="line">y.right.p &#x3D; y</span><br><span class="line">transplant(T,z,y)</span><br><span class="line">y.left &#x3D; z.left</span><br><span class="line">y.left.p &#x3D; y</span><br></pre></td></tr></table></figure><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>卫星数据: 在算法导论里，指的是一条纪录（一个对象中）中除了关键字key以外的其他数据。</p><p>NIL:表示空，和Java中的null一样</p>]]></content>
      
      
      <categories>
          
          <category> data structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tree</title>
      <link href="/sunshine-carroll.github.io/2020/11/16/tree/"/>
      <url>/sunshine-carroll.github.io/2020/11/16/tree/</url>
      
        <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>这个不是介绍性的文章，纯粹是笔记。</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>不含简单回路的连通图</p><h2 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h2><p>一个无向图是树，当且仅当他的每对顶点之间存在唯一简单通路</p><p>含n个结点的树具有n-1条边</p><h2 id="有序根树"><a href="#有序根树" class="headerlink" title="有序根树"></a>有序根树</h2><h3 id="递归定义"><a href="#递归定义" class="headerlink" title="递归定义"></a>递归定义</h3><blockquote><p>基础步骤: 单个顶点是根树</p><p>归纳步骤: 如果$T_1,T_2,T_3,\cdots,T_n$是根树，分别带有树根$r_1,r_2,r_3,\cdots,r_n$,则如下形成的树也是根树：从树根r开始(r不属于$T_1,T_2,T_3,\cdots,T_n$中的一个),对于每个顶点$r_1,r_2,r_3,\cdots,r_n$,都加入一条r到该顶点的边。</p></blockquote><h3 id="非递归定义"><a href="#非递归定义" class="headerlink" title="非递归定义"></a>非递归定义</h3><blockquote><p>有序根树是指顶点作为根并且每条边的方向都离开根的树</p></blockquote><h3 id="m叉树"><a href="#m叉树" class="headerlink" title="m叉树"></a>m叉树</h3><blockquote><p>若有序根树的每个内点都有不超过m个孩子，那么称他为m叉树。如果每个内点都含m个孩子，那么称之为满m叉树。当m=2时的m叉树也称2叉树</p></blockquote><h2 id="扩展二叉树"><a href="#扩展二叉树" class="headerlink" title="扩展二叉树"></a>扩展二叉树</h2><blockquote><p>基础步骤: 空集是扩展二叉树</p><p>归纳步骤: 如果$T_1,T_2$是扩展二叉树，那么存在一个扩展二叉树$T_1·T_2$,他包含树根r,和从r连接这两个子树的边(仅当子树非空时才连接边)</p></blockquote><h2 id="满二叉树-这里是离散数学及其应用上满二叉树的定义"><a href="#满二叉树-这里是离散数学及其应用上满二叉树的定义" class="headerlink" title="满二叉树(这里是离散数学及其应用上满二叉树的定义)"></a>满二叉树(这里是离散数学及其应用上满二叉树的定义)</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>基础步骤: 存在只含单个顶点的满二叉树</p><p>归纳步骤: 如果$T_1,T_2$是满二叉树，那么存在一个满二叉树$T_1·T_2$,他包含树根r,和从r连接这两个子树的边</p></blockquote><h3 id="满二叉树的高度h-T"><a href="#满二叉树的高度h-T" class="headerlink" title="满二叉树的高度h(T)"></a>满二叉树的高度h(T)</h3><blockquote><p>基础步骤：只含树根的满二叉树高度$h(T)=0$</p><p>归纳步骤: 如果$T_1,T_2$是满二叉树，那么满二叉树$T=T_1·T_2$的高度$h(T)=max(h(T_1),h(T_2))+1$</p></blockquote><h2 id="满二叉树的顶点数n-T"><a href="#满二叉树的顶点数n-T" class="headerlink" title="满二叉树的顶点数n(T)"></a>满二叉树的顶点数n(T)</h2><blockquote><p>基础步骤：只含树根的满二叉树高度$n(T)=1</p><p>归纳步骤: 如果$T_1,T_2$是满二叉树，那么满二叉树$T=T_1·T_2$的顶点数$n(T)=n(T_1)+n(T_2)+1$</p></blockquote><h3 id="关于满二叉树的一些结论及其证明"><a href="#关于满二叉树的一些结论及其证明" class="headerlink" title="关于满二叉树的一些结论及其证明"></a>关于满二叉树的一些结论及其证明</h3><blockquote><p>定理一 假设T是满二叉树，n(T)是T的顶点数，h(T)是T的高度,那么$n(T)&lt;= 2^{h(T)+1}-1$</p></blockquote><p>证明:</p><p>基础步骤: 当T是只含树根的满二叉树的时候，n(T) = 1,h(T)=0，$1&lt;=2^{0+1}-1$ 定理一成了</p><p>归纳步骤:如果$T_1,T_2$是满二叉树,$n(T_1)&lt;=2^{h(T_1)+1}-1$,$n(T_2)&lt;=2^{h(T_2)+1}-1$<br>$$<br>\begin{align}<br>n(T)&amp;=n(T_1)+n(T_2)+1\<br>&amp;&lt;=2^{h(T_1)+1}-1 + 2^{h(T_2)+1}-1 +1\<br>&amp;&lt;=2^{max(h(T_1)+1,h(T_2)+1)+1} -1\<br>&amp;=2^{h(T)+1}-1<br>\end{align}<br>$$<br>定理一也成立</p><blockquote><p>满二叉树的所有非叶节点都有度数都为2</p></blockquote><h2 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h2><p>任意子树的高度差不超过1的树</p><h2 id="完美二叉树-Perfect-Binary-Tree"><a href="#完美二叉树-Perfect-Binary-Tree" class="headerlink" title="完美二叉树(Perfect Binary Tree )"></a>完美二叉树(Perfect Binary Tree )</h2><p>高度为h，且具有$2^{h+1}-1$个结点的树</p><h2 id="完全二叉树-Complete-Binary-Tree"><a href="#完全二叉树-Complete-Binary-Tree" class="headerlink" title="完全二叉树(Complete Binary Tree)"></a>完全二叉树(Complete Binary Tree)</h2><p>根结点到倒数第二层都是完美二叉树，只有最后一层可以不完全填充，且节点靠左</p><h2 id="有序根树的前序遍历"><a href="#有序根树的前序遍历" class="headerlink" title="有序根树的前序遍历"></a>有序根树的前序遍历</h2><blockquote><p>设T是带有树根r的有序根树，如果T只含树根r，则r是T的前序遍历。否则，设$T_1,T_2,T_3,\cdots,T_n$是T以r为根的从左到右的子树，前序遍历先访问r，再从左到右前序遍历$T_1,T_2,T_3,\cdots,T_n$</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">procedure preorder(T:有序根树)</span><br><span class="line">r &#x3D; T的根</span><br><span class="line">visit(r)</span><br><span class="line">for 从左到右的r的子树c</span><br><span class="line">preorder(c)</span><br></pre></td></tr></table></figure><h2 id="有序根树的中序遍历"><a href="#有序根树的中序遍历" class="headerlink" title="有序根树的中序遍历"></a>有序根树的中序遍历</h2><blockquote><p>设T是带有树根r的有序根树，如果T只含树根r，则r是T的中序遍历。否则，设$T_1,T_2,T_3,\cdots,T_n$是T以r为根的从左到右的子树，先中序遍历$T_1$,然后访问r，接着中序遍历$T_2,T_3,\cdots,T_n$</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">procedure inorder(T:有序根树)</span><br><span class="line">r &#x3D; T的根</span><br><span class="line">if r 是树叶 then visit(r)</span><br><span class="line">else</span><br><span class="line">l 是r从左到右的第一个子树</span><br><span class="line">inorder(l)</span><br><span class="line">visit(r)</span><br><span class="line">for 从左到右的r的子树c(不包含l)</span><br><span class="line">inorder(c)</span><br></pre></td></tr></table></figure><h2 id="有序根树的后序遍历"><a href="#有序根树的后序遍历" class="headerlink" title="有序根树的后序遍历"></a>有序根树的后序遍历</h2><blockquote><p>设T是带有树根r的有序根树，如果T只含树根r，则r是T的后序遍历。否则，设$T_1,T_2,T_3,\cdots,T_n$是T以r为根的从左到右的子树，先后序遍历$T_1,T_2,T_3,\cdots,T_n$,然后访问r。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">procedure postorder(T:有序根树)</span><br><span class="line">r &#x3D; T的根</span><br><span class="line">for 从左到右的r的子树c</span><br><span class="line">postorder(c)</span><br><span class="line">visit(r)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> data structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Map接口分析</title>
      <link href="/sunshine-carroll.github.io/2020/10/29/Map%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90/"/>
      <url>/sunshine-carroll.github.io/2020/10/29/Map%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p><code>Map</code>,在数学中时映射的意思，</p><p>为了便于理解与表述，我们通过一个简单的Map模型来分析,这个模型由一些作者和笔者看过的作品构成</p><p>$$<br>\begin{align}<br>&amp;f:author→book \<br>唐家三少&amp;｜余华 \ |Jostein Gaarder \tag {author}\<br>斗罗大陆&amp;｜活着 \ |苏菲的世界\tag {book}\<br>\end{align}<br>$$</p><h2 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h2><p>从$f:author→book$中可以看出一个映射(Map)可以由一个个由<code>[余华-活着)]</code>这样的条目(Entry)组成。因此Map<code>有一个内部接口</code>Entry，</p><p>这个接口定义了Map实现中的内部类entry的类型，内部类作用之一就是在面对概念宽泛，或者说复杂的类型建模的时候，去识别复杂类型中内部的类型(不管你对这个类型的认识程度)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">  <span class="function">K <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">V get <span class="title">Value</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">setValue</span><span class="params">(V value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//··· some static methods</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Map以及Entry中的泛型参数中的K是Map中键的类型(author),V是值的类型(book)，Entry 类型的行为并不多,举个例子 对于【唐家三少-斗罗大陆】这样一个条目，我们可能会想要获取他的作者唐家三少(getKey),或者获取作品(getValue)，或者替换作品为天珠变(setValue),以及与一个Entry比较是否相等。在这里要注意的是不管是简单类型或者复杂类型，都有其等价性，我们甚至可以认为。【唐家三少-斗罗大陆】和【banana-apple】是等价的，他们同是语言的符号。hashCode() 和 equals()是相关的(当然也可以实现成无关)，一般对于任意两个对象a,b 如果a,b等价，那么他们的hashCode()返回也应该一样。</p><p>等价性是建立在某种前提上的，我们可以认为人不可以踏入同一条河流两次，因为河水是流动的，也可以认为人可以踏入同一条河流中两次，因为只关心河流的地理位置，有兴趣可以看看下面这个拓展</p><blockquote><p>🍀 关于equals 和 hashCode 的详细解释以及对容器类库中容器行为的影响可以参考<a href="https://lingcoder.gitee.io/onjava8/#/book/Appendix-Understanding-equals-and-hashCode?id=%E9%99%84%E5%BD%95%E7%90%86%E8%A7%A3equals%E5%92%8Chashcode%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">On java 8-理解equals和hashcode方法 </a>或者Effective Java 第<a href="https://jiapengcai.gitbooks.io/effective-java/content/di-3-zhang-dui-suo-you-dui-xiang-du-tong-yong-de-fang-fa/di-10-tiao-ff1a-fu-gai-equals-fang-fa-shi-qing-zun-shou-tong-yong-yue-ding.html" target="_blank" rel="noopener">10,11</a>条建议<br></p></blockquote><h2 id="Map的行为"><a href="#Map的行为" class="headerlink" title="Map的行为"></a>Map的行为</h2><p>随着Java语言的发展，类库的完善，新特性的增加Map接口的行为也越来越丰富。我们在使用一个类型的时候，通常只关心该类型对外表现的行为，并且不太会涉及到这个类型的所有行为。这些内容有时候会是十分复杂的，不管是了解一个类型还是去设计一个类型，过早的涉及这些复杂性是不太有必要的，而且可能会迷失在这些复杂性中。举个例子，一个服装设计师在小的时候可能对服装的设计一窍不通，服装是怎么制作的，该怎么设计，但是他能对服装给人提供的遮衣蔽体，修身等功能建立起认识，随着学习和进修慢慢了解到服装设计纠结是什么。Java类库中实现Map接口的类型有很多,HashMap，LinkedHashMap,TreeMap等等，他们各自的实现和行为都有不同，但是他们的共同特征都是Map，有时候将行为和实现拆分的看可以很好的去认识一个类库，框架。Map接口一共定义了25个行为(方法),这25种行为可以划分为6个类别。</p><blockquote><p>🍀 有时候对象的特征是直观的,但是行为却有很多，这些行为说出来挺容易理解，全部记住也没必要。正如之前的模型，很容易在脑海中留下印象并复述内容。map描述的25种行为都可以应用在模型中，但是让人凭空说却挺麻烦。举个别的例子说整数，整数大家小时候就认识，但是整数能表现的行为却很多。整数可以进行模指数运算(这在RSA加密算法有关键的作用，而RSA加密算法是数据在通过Https安全传输时的一个重要环节)，可以判断整数是否为梅森素数，网络中有一个庞大的分布式系统<a href="https://www.mersenne.org/" target="_blank" rel="noopener">gimps</a> EFF关于奖金设立的规定，任何一位新梅森素数的发现者都将获得3000美元的研究发现奖。</p></blockquote><p>下面是Java8中 java.Util.Map 接口的部分内容，这里省略了具体的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// Query Operations 查询对象内部的状态的操作</span></span><br><span class="line">  ···</span><br><span class="line">  <span class="comment">// Modification Operations 改变对象内部状态的操作</span></span><br><span class="line">  ···</span><br><span class="line">  <span class="comment">// Bulk Operations 批量操作</span></span><br><span class="line">  ···</span><br><span class="line">  <span class="comment">// views 返回视图</span></span><br><span class="line">  ···</span><br><span class="line">  <span class="comment">// Comparison and hashing 比较和散列</span></span><br><span class="line">  ···</span><br><span class="line">  <span class="comment">//Defaultable methods 默认方法</span></span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Query-Operations"><a href="#Query-Operations" class="headerlink" title="Query Operations"></a>Query Operations</h3><p>查询操作，一个查询操作仅仅返回并且不会修改对象的状态。一个无状态对象是线程安全的，一个不会修改对象状态的方法也是线程安全的，不会导致对象处于不一致的状态下(理由就很简单，因为根本不改变状态)。</p><blockquote><p>🍀 查询操作时线程安全的，但是对查询出来的对象的操作却不一定是线程安全的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// Query Operations 查询对象内部的状态的操作</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span></span>;</span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(Object key)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java 1.8 Map接口 一共有5个query 方法，查看map的大小，判断map是否为空，是否存在某个key，是否存在某个value，获取key对应的value。这些方法的功能见名知意，从功能性上考虑对于各个map的实现，这些接口大同小异。有时侯一些小差异容易导致意想不到的问题，如抛出NullPointException的抛出。在HashMap中 get 方法允许参数为null,但在TreeMap的一些情况下，不允许为空。这些不是本文的主旨，具体的还请看方法文档</p><blockquote><p>🍀 TreeMap 会在使用自然序，或者Comparator不允许空键的时候抛出NullPointException</p></blockquote><h3 id="Modification-Operations"><a href="#Modification-Operations" class="headerlink" title="Modification Operations"></a>Modification Operations</h3><p>修改操作，被Map接口划分为修改操作只有两个put(向map中放入一个条目)，remove(根据键移除一个条目)。事实上下面属于Bulk类别的操作也会修改内部的状态(其实还有defaultable方法 后面会提)。Map接口的设计者把他们按照操作对象的数量细分了。修改操作是对应查询操作的,一个修改操作不一定是线程安全的，在使用修改操作是需要考虑其Map实现的线程安全性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line"><span class="function">V <span class="title">remove</span><span class="params">(Object key)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bulk-Operations"><a href="#Bulk-Operations" class="headerlink" title="Bulk Operations"></a>Bulk Operations</h2><p>Bulk(n : 大多数，大部分；大块) 操作，操作的对象不止Map中的一个条目。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clear()就是清空Map, putAll 能将另一个Map中的条目合并到这个条目</p><h2 id="Views"><a href="#Views" class="headerlink" title="Views"></a>Views</h2><p>视图: 对外展示Map的视图，这些Map内部状态发生变化时，会反应在这些视图中，Map接口规定可以通过这些视图去移除(不能添加)Map的内部元素。因此在迭代这些Map，或者视图的时候，如果通过视图或者map的方法修改了Map，就会抛出ConcurrentModificationException。如果要避免抛出这个异常，可以拷贝一份视图，然后做别的操作。</p><blockquote><p>❗️这里的视图和一些地方说的不一样，这里指对象对外返回的内部状态。一些地方把返回的不能改变内部状态的对象叫视图，能改变内部状态的叫句柄。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"><span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>;</span><br><span class="line">Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>🍀 有时候我们需要返回的视图能够实时的反应内部状态，但不允许使用者能够通过视图来修改内部状态。关于一个对象应该如何对外展示内部的状态，可以参考《Java并发编程实战》中的对象发布和溢出部分。</p></blockquote><h2 id="Defaultable-methods"><a href="#Defaultable-methods" class="headerlink" title="Defaultable methods"></a>Defaultable methods</h2><p>可以默认实现的方法。在以前Java的容器类库中，一种通用的设计方式是定义接口，在接口中描述行为，然后使用抽象类来实现这个接口，如果某个方法可以通过组合对象中其他方法或者使用对象的内部状态来实现，那么这些实现会编写在这个抽象类中，以达到代码复用等一些目的。但是有些方法其实不需要直接操作对象的内部状态，Java8 接口允许 default 修饰的方法带有方法体，Map接口定义了一些 Defaultable 方法 他们组合上述的方法，然后加上一些控制执行流程，在不直接改变对象内部行为的情况表现自己的行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">default</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//···</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//···</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; function)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//···</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//···</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//···</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//···</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//···</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> V <span class="title">computeIfAbsent</span><span class="params">(K key,</span></span></span><br><span class="line"><span class="function"><span class="params">            Function&lt;? <span class="keyword">super</span> K, ? extends V&gt; mappingFunction)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//···</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> V <span class="title">computeIfPresent</span><span class="params">(K key,</span></span></span><br><span class="line"><span class="function"><span class="params">            BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//···</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> V <span class="title">compute</span><span class="params">(K key,</span></span></span><br><span class="line"><span class="function"><span class="params">            BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//···</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> V <span class="title">merge</span><span class="params">(K key, V value,</span></span></span><br><span class="line"><span class="function"><span class="params">            BiFunction&lt;? <span class="keyword">super</span> V, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//···</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> collections </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP</title>
      <link href="/sunshine-carroll.github.io/2020/10/13/Spring-AOP/"/>
      <url>/sunshine-carroll.github.io/2020/10/13/Spring-AOP/</url>
      
        <content type="html"><![CDATA[<h2 id="AOP概念"><a href="#AOP概念" class="headerlink" title="AOP概念"></a>AOP概念</h2><ul><li><p><code>Aspect</code>: A modularization of a concern that cuts across multiple classes</p></li><li><p><code>Join point</code>: 程序执行期间的某个时间点(point)。如方法的执行，或者异常的处理，在Spring AOP 中一个<code>Join point</code> </p><p>通常表示方法执行</p></li><li><p><code>Advice</code>: 被一个<code>Aspect</code>在一个特定的<code>Join point</code>上采用的动作，<code>Advice</code>有许多类型，包括<code>around</code>,<code>before</code>,<code>after</code>等，</p><p><code>Advice</code>类型稍后展示。许多AOP框架，包括Spring,将<code>Advice</code> 建模为拦截器，并在<code>Join point</code>上维持一条拦截器链</p></li><li><p><code>Pointcut</code>:一句匹配<code>Join points</code> 的断言，<code>Advice</code>关联着一个<code>Pointcut expression</code>，并且运行在任意一个被</p><p><code>Pointcut</code>匹配的<code>Join point</code>上。</p></li><li><p><code>Introduction</code>: 替一个类声明额外的方法或者属性，Spring AOP 使你能够向一个被通知(advised)的对象引入新的接口</p><p> (和相应的实现)</p></li><li><p><code>Target object</code>: 被一个或者多个<code>Aspect</code>通知(advise)的对象，也称为<code>advised object</code>。由于Spring使用runtime proxies实现AOP，这个对象总是被代理的对象。</p></li><li><p><code>AOP proxy</code>:以实现Aspect contracts为目的(通知方法执行等)被AOP 框架创建的对象，在Spring中一个AOP proxy 是JDK dynamic proxy 或者 CGLIB proxy</p></li><li><p><code>Weaving</code>: 将<code>Aspects</code>和应用中的类或者对象连接起来创建一个<code>advised object</code>。这个操作可以在编译时(e.g 使用AspectJ compiler),加载时，或者运行时完成。与其他的纯JavaAOP框架一样，Spring 在运行时执行<code>Weaving</code></p></li></ul><h2 id="Spring-AOP-通知的类型"><a href="#Spring-AOP-通知的类型" class="headerlink" title="Spring AOP 通知的类型"></a>Spring AOP 通知的类型</h2><ul><li><code>Before advice</code>: 运行在<code>Join point</code> 之前的<code>Advice</code>，但是没有阻止执行流走向<code>Join point</code>的能力(除非抛出异常)</li><li><code>After returning advice</code>: 运行在<code>Join point</code> 正常完成之后的<code>Advice</code> (e.g 一个方法没有抛出异常正常返回).</li><li><code>After throwing advice</code>: 当方法由于抛出异常退出后运行的<code>Advice</code></li><li><code>After (finally) advice</code>: 无论<code>Join point</code> 以何种方式退出都会执行的<code>Advice</code> (正常或异常退出).</li><li><code>Around advice</code>: 环绕<code>Join point</code>(如方法调用)的<code>Advice</code>. 这是功能最强大的一种通知.<code>Around advice</code> 可以在方法调用前或调用执行自定义的行为 它还负责选择是继续到<code>Join point</code>，还是通过返回自己的返回值或抛出异常来简化被通知(advised)的方法的执行。</li></ul><h2 id="Pointcut-Designators"><a href="#Pointcut-Designators" class="headerlink" title="Pointcut Designators"></a>Pointcut Designators</h2><ul><li><p><code>execution</code>:For matching method execution join points. This is the primary pointcut designator to use when working with Spring AOP.</p></li><li><p><code>within</code>: Limits matching to join points within certain types (the execution of a method declared within a matching type when using Spring AOP).</p></li><li><p><code>this</code>: Limits matching to join points (the execution of methods when using Spring AOP) where the bean reference (Spring AOP proxy) is an instance of the given type.</p></li><li><p><code>targe</code>t: Limits matching to join points (the execution of methods when using Spring AOP) where the target object (application object being proxied) is an instance of the given type.</p></li><li><p><code>args</code>: Limits matching to join points (the execution of methods when using Spring AOP) where the arguments are instances of the given types.</p></li><li><p><code>@target</code>: Limits matching to join points (the execution of methods when using Spring AOP)</p></li><li><p><code>@args</code>: Limits matching to join points (the execution of methods when using Spring AOP) where the runtime type of the actual arguments passed have annotations of the given types.</p></li><li><p><code>@within</code>: Limits matching to join points within types that have the given annotation (the execution of methods declared in types with the given annotation when using Spring AOP).</p></li><li><p><code>@annotation</code>: Limits matching to join points where the subject of the join point (the method being executed in Spring AOP) has the given annotation.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>事务(一)</title>
      <link href="/sunshine-carroll.github.io/2020/09/11/%E4%BA%8B%E5%8A%A1-%E4%BA%8C-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%8C%81%E4%B9%85%E6%80%A7/"/>
      <url>/sunshine-carroll.github.io/2020/09/11/%E4%BA%8B%E5%8A%A1-%E4%BA%8C-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%8C%81%E4%B9%85%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="事务的原子性和持久性"><a href="#事务的原子性和持久性" class="headerlink" title="事务的原子性和持久性"></a>事务的原子性和持久性</h2><p>一个数据库的事务并不是总能成功执行的。事务未成功执行后的事务就是中止的事务,称事务<code>已中止</code>，为了保证原子性，这样的事务对数据库的影响必须撤销，一个中止的事务对数据库造成的影响被撤销，就说事务<code>已回滚</code>，成功完成的事务成为<code>已提交</code>.数据库的恢复机制负责管理事务的中止。典型的方法是维护一个日志，事务对数据库的修改都会记录到日志中，记录之后才会修改数据库。日志功能提供了两种方式保证原子性或持久性。</p><ul><li>重做修改，保证原子性和持久性。</li><li>撤销修改，保证原子性。</li></ul><h3 id="事务的状态"><a href="#事务的状态" class="headerlink" title="事务的状态"></a>事务的状态</h3><p>有一种抽象的事务模型把事务划分为一下几个状态:</p><ul><li><code>活动的</code>(active)：初始状态。事务执行时处于这个状态</li><li><code>部分提交的</code>(partially committed)：最后一条语句执行后</li><li><code>失败的</code>(failed)：发现正常的执行不能继续后</li><li><code>中止的</code>(aborted)：事务回滚</li><li><code>提交的</code>(committed)：成功完成后</li></ul><p>状态图如下所示</p><img src="/sunshine-carroll.github.io/2020/09/11/%E4%BA%8B%E5%8A%A1-%E4%BA%8C-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%8C%81%E4%B9%85%E6%80%A7/state_diagram_of_a_transaction.png" alt="state_diagram_of_a_transaction" style="zoom:50%;"><ul><li>当事务开始时处于<code>active</code></li><li><code>active</code>-&gt; <code>partially committed</code>: 完成事务中最后一条语句</li><li><code>active</code>-&gt; <code>failed</code>: 发现正常的执行不能继续</li><li><code>partially committed</code> -&gt; <code>committed</code>:成功完成后</li><li><code>partially committed</code> -&gt; <code>failed</code>: 发现正常的执行不能继续</li><li><code>failed</code> -&gt; <code>aborted</code>:失败的事务回滚后</li></ul><p>事务进入中止系统可以有两种操作:</p><ol><li><p>重启事务:当事务的中止是由于硬件错误或不是由于事务的内部逻辑错误导致的</p></li><li><p>杀死事务:当事务的中止是由于事务内部执行逻辑错误导致的</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> transaction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>领域驱动设计架构</title>
      <link href="/sunshine-carroll.github.io/2020/09/10/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/"/>
      <url>/sunshine-carroll.github.io/2020/09/10/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h2><img src="/sunshine-carroll.github.io/2020/09/10/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/sunshine/blog/source/_posts/2020-09-10-领域驱动设计架构/layered_architecture_01.png" alt="layered_architecture_01" style="zoom: 33%;"><h3 id="严格分层架构和非严格分层架构"><a href="#严格分层架构和非严格分层架构" class="headerlink" title="严格分层架构和非严格分层架构"></a>严格分层架构和非严格分层架构</h3><h3 id="加入依赖倒置"><a href="#加入依赖倒置" class="headerlink" title="加入依赖倒置"></a>加入依赖倒置</h3><h2 id="六边形架构"><a href="#六边形架构" class="headerlink" title="六边形架构"></a>六边形架构</h2>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> 领域驱动设计(Domain Driven Design) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring cloud 概览</title>
      <link href="/sunshine-carroll.github.io/2020/09/10/Spring-cloud-%E7%BB%84%E4%BB%B6%E6%A6%82%E8%A7%88/"/>
      <url>/sunshine-carroll.github.io/2020/09/10/Spring-cloud-%E7%BB%84%E4%BB%B6%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<p>博客逐渐完善中</p><h2 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h2><p>微服务架构是一种新常态，可以构建小型的，独立的,随时可以运行的应用程序，它的可以带来强大的可伸缩性，并使代码更具适应性。</p><h2 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a>Spring Cloud Gateway</h2>]]></content>
      
      
      <categories>
          
          <category> Spring cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> overview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务(一)</title>
      <link href="/sunshine-carroll.github.io/2020/09/09/%E4%BA%8B%E5%8A%A1-%E4%B8%80/"/>
      <url>/sunshine-carroll.github.io/2020/09/09/%E4%BA%8B%E5%8A%A1-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>#事务概念</p><p>​        事务是访问可能更新各种数据项的一个程序执行单元(单一逻辑工作单元的操作集合)。具有原子性，一致性，隔离性，持久性四个特点简称ACID特性。</p><ol><li><p><code>原子性</code>（Atomicity）事务中所有的操作要么全部正确的反应出来，要么全部不反应。</p></li><li><p><code>一致性</code>(Consistency) 隔离执行事务时(没有其他事物执行的情况下)，保持数据库的一致性。单个事务的一致性是编写事务人员的责任。</p></li><li><p><code>隔离性</code>(Isolation)    在事务并发执行中，各个事务都感觉不到系统中有其他事务执行。对于任意两个事务$T_i,T_j$,对于$T_i$看来，</p><p>$T_j$在$T_i$开始执行之前就执行完成，或者$T_j$在$T_i$执行完毕后完成。</p></li><li><p><code>持久性</code>(Durability) 一个事务发生后，对数据库的改变必须是永久的，即使系统出现故障。</p></li></ol><h2 id="简单的事物模型"><a href="#简单的事物模型" class="headerlink" title="简单的事物模型"></a>简单的事物模型</h2><ul><li>read(X) : 从数据库把数据项X传送到执行read操作的事务的主存缓冲区的一个也称之为X的变量中。</li><li>write(X) : 从执行write的事务的主存缓冲区中的变量X传送会回数据库。 </li></ul><p>假设有事务$T_i$，$T_i$执行的操作是把A账户中的¥50过户给B，其过程可以如下<br>$$<br>\begin{align}<br>T_i:&amp;read(A)\<br>&amp;A = A - 50;\<br>&amp;write(A);\<br>&amp;read(B);\<br>&amp;B = B + 50;\<br>&amp;write(B);<br>\end{align}<br>$$<br>我们从这个例子中去看事务的<code>ACID</code>特性</p><ul><li><p><code>原子性</code></p><p>从上面的概念中可知，原子性指事务中所有的操作要么全部正确的反应出来，要么全部不反应的特性。</p><p>在过户操作中，账户A,B的财产总和应该是相同的，这是一条一致性约束，假设没有原子性，事务$T_i$在执行完wirte(A)后，由于系统故障或者别的什么原因中止，从账户A中扣款的¥50就不会到账户B中,就会违反一致性。</p></li><li><p><code>一致性</code></p><p>就如原子性中所说，账户A,B的财产总和应该是相同的，如果数据库在过户操作之前是满足约束的，那么过户之后也应该满足约束。事务的一致性不全由数据库承担，编写事务是程序员应该确保单一事务的一致性</p></li><li><p><code>持久性</code></p><p>假如过户操作一旦执行完毕，系统必须保证任何系统故障都不会导致相关数据丢失</p></li><li><p><code>隔离性</code></p><p>就算单个事务是一致的，但当事务并发执行后，没有别的机制的影响，依旧会导致数据库处于不一致状态。</p><p>假设有事务$T_j$：<br>$$<br>\begin{align}<br>T_i:&amp;read(A)\<br>&amp;A = A - 50;\<br>&amp;write(A);\<br>&amp;read(C);\<br>&amp;C = C + 50;\<br>&amp;write(C);<br>\end{align}<br>$$<br>事务$T_i$在执行wirte(A)之前,事务$T_j$执行完write(A).之后由于调度继续执行事务$T_i$那么事务$T_j$写入的数据就会被错误的覆盖，就会违反一致性约束。事务的隔离性要确保事务并发执行后系统的状态要和这些事务串行执行后的一样</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> transaction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bean-scope</title>
      <link href="/sunshine-carroll.github.io/2020/09/09/bean-scope/"/>
      <url>/sunshine-carroll.github.io/2020/09/09/bean-scope/</url>
      
        <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><table><thead><tr><th>Scope</th><th>Description</th></tr></thead><tbody><tr><td><code>singleton</code></td><td>(Default) Scopes a single bean definition to a single object instance for each Spring IoC container.</td></tr><tr><td><code>prototype</code></td><td>Scopes a single bean definition to any number of object instances.</td></tr><tr><td><code>request</code></td><td>Scopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring ApplicationContext.</td></tr><tr><td><code>session</code></td><td>Scopes a single bean definition to the lifecycle of an HTTP Session. Only valid in the context of a web-aware Spring ApplicationContext.</td></tr><tr><td><code>application</code></td><td>Scopes a single bean definition to the lifecycle of a ServletContext. Only valid in the context of a web-aware Spring ApplicationContext.</td></tr><tr><td><code>websocket</code></td><td>Scopes a single bean definition to the lifecycle of a WebSocket. Only valid in the context of a web-aware Spring ApplicationContext.</td></tr></tbody></table><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ul><li><p>Spring singleton 和 设计模式singleton的区别？</p><p>Spring singleton相对于一个Ioc容器，设计模式的 singleton 相对于一个类加载器。</p></li><li><p>Scope是否只有上面的6种？</p><p>否，Spring的scope是可扩展的，官方文档中详细的描述了如何自定义Scope <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes-custom" target="_blank" rel="noopener">快捷链接</a>。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ioc容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查询处理(二)</title>
      <link href="/sunshine-carroll.github.io/2020/09/04/%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86(%E4%BA%8C)/"/>
      <url>/sunshine-carroll.github.io/2020/09/04/%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h2 id="代价度量"><a href="#代价度量" class="headerlink" title="代价度量"></a>代价度量</h2><p>影响一次查询执行的代价有很多，磁盘读取，CPU执行，并行/分布式数据库系统中的通信代价等。有些代价难以度量，并且并非主要代价，这里使用磁盘搜索次数和传送磁盘块数来度量查询执行计划的代价。假设磁盘子系统传输一个磁盘块的时间为$t_s$,一次磁盘搜索的时间为$t_T$。</p><h2 id="选择运算的代价估计"><a href="#选择运算的代价估计" class="headerlink" title="选择运算的代价估计"></a>选择运算的代价估计</h2><p>考虑所有元组都存在单一文件关系上的一个选择运算。</p><p>注意一般$B^+$树非叶节点小于总结点数的1%，$B^+$树 n的大小一般等于磁盘块大小。</p><table><thead><tr><th align="center"></th><th align="center">算法</th><th align="center">开销</th><th align="center">原因</th></tr></thead><tbody><tr><td align="center">$A_1$</td><td align="center">线性搜索</td><td align="center">$t_s+b_r\times t_T$</td><td align="center">一次初始搜索，加$b_r$次块传输</td></tr><tr><td align="center">$A_2$</td><td align="center">线性搜索,码等值比较</td><td align="center">平均情形: $t_s+(b_r/2)\times t_T$</td><td align="center">由于最多只有一条记录满足条件，搜索到数据就能终止搜索</td></tr><tr><td align="center">$A_3$</td><td align="center">$B^+$树主索引，码等值比较</td><td align="center">$(h_i+1)(t_T+t_s)$</td><td align="center">$h_i$是$B^+$树的高度。根据$B^+$树查找记录的算法，查找时，穿越整棵树的高度，每次穿越都需要一次搜索和传输找到结点，最后一次传输和搜索找到记录</td></tr><tr><td align="center">$A_4$</td><td align="center">$B^+$树主索引，非码等值比较</td><td align="center">$h_i(t_T+t_s)+b\times t_T$</td><td align="center">由于数据按主索引存储不需要额外的搜索，b是存储比较值的块数</td></tr><tr><td align="center">$A_5$</td><td align="center">$B^+$树辅助索引，码等值比较</td><td align="center">$(h_i+1)(t_T+t_s)$</td><td align="center">和主索引类似</td></tr><tr><td align="center">$A_6$</td><td align="center">$B^+$树辅助索引，非码等值比较</td><td align="center">$(h_i+n)(t_T+t_s)$</td><td align="center">n表示取到的记录数,辅助索引索引顺序于存储顺序不同，查找到n条记录，就需要n次磁盘传输和磁盘搜索，再加上$B^+$树高度的穿越</td></tr><tr><td align="center">$A_7$</td><td align="center">$B^+$树主索引，比较</td><td align="center">$h_i(t_T+t_s)+b\times t_T$</td><td align="center">根据$B^+$树取数据的过程，符合条件的索引值是连续的，存储的位置也是连续的，不管是等值比较还是比较，过程都类似，且取数据的过程都不需要额外的磁盘搜索</td></tr><tr><td align="center">$A_8$</td><td align="center">$B^+$树辅助索引，比较</td><td align="center">$(h_i+n)(t_T+t_s)$</td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>从表中可以看出一些特点</p><ul><li>不论是$B^+$树主索引 还是 $B^+$树辅助索引，进行非码等值比较时和比较的开销都相同，这是由$B^+$树搜索过程决定的。不同的是主索引的存储顺序和记录存储顺序相同，相较于辅助索引，取数据不需要额外的磁盘搜索操作</li><li>对于等值比较，码等值比较由于只有0个或一个匹配项，不管是辅助索引还是主索引，都不会存在由于数据存储顺序出现的额外的磁盘搜索，非码等值比较有0个或多个匹配项，辅助索引上的非码等值比较由于数据存储顺序和索引顺序不同，每个匹配项都需要一次磁盘搜索和磁盘传输</li></ul>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 查询处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql查询执行计划</title>
      <link href="/sunshine-carroll.github.io/2020/08/31/mysql%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
      <url>/sunshine-carroll.github.io/2020/08/31/mysql%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>查询执行计划是一个带如何执行的注释的关系代数运算序列，由优化器将高级数据库语言翻译成文件系统物理层上能够使用的查询执行计划。</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/execution-plan-information.html" target="_blank" rel="noopener">参考链接</a></p><h2 id="mysql查询执行计划"><a href="#mysql查询执行计划" class="headerlink" title="mysql查询执行计划"></a>mysql查询执行计划</h2><p>mysql 的查询执行计划展示mysql如何去执行sql语句的信息，可以用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> &lt;<span class="keyword">statement</span>&gt;</span><br></pre></td></tr></table></figure><p> 来查看查询执行计划，<code>explain</code>关键字可以作用于<code>insert</code>,<code>delete</code>,<code>update</code>,<code>replace</code>,<code>select</code> 语句上</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>假设有两个关系 <code>instructor</code> 和 <code>department</code> 他们的关系模式如下<br>$$<br>\begin{align}<br>&amp;instrucor(id,name,dept_name,salary)\<br>&amp;department(dept_name,building,budget)<br>\end{align}<br>$$<br>假设我们要找到Psychology系所有instructor的名称，其sql语句可以如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> instructor.name,instructor.dept_name <span class="keyword">from</span> instructor  <span class="keyword">inner</span> <span class="keyword">join</span> department <span class="keyword">on</span> instructor.dept_name = department.dept_name <span class="keyword">where</span> department.dept_name = <span class="string">'Psychology'</span></span><br></pre></td></tr></table></figure><p>通过MySQLWorkbench explain 可以得到他的查询计划</p><p><img src="/sunshine-carroll.github.io/2020/08/31/mysql%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/execution_plain_table.png" alt="exection_plain_table"></p><p>此外MySQLWorkbench 还提供了图形化的查询执行计划展示</p><p><img src="/sunshine-carroll.github.io/2020/08/31/mysql%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/execution_plan_graph.png" alt="execution_plan_graph"></p><p>下面这个表格解释了输出的查询执行计划中各个字段的含义</p><table><thead><tr><th>Column</th><th>JSON Name</th><th>Meaning</th></tr></thead><tbody><tr><td>id</td><td>select_id</td><td>SELECT 标志(The SELECT identifier)</td></tr><tr><td>select_type</td><td>None</td><td>SELECT 类型(The SELECT type)</td></tr><tr><td>table</td><td>table_name</td><td>输出行所在的表(The table for the output row)</td></tr><tr><td>partitions</td><td>partitions</td><td>匹配的分区(The matching partitions)</td></tr><tr><td>type</td><td>access_type</td><td>连接类型(The join type)</td></tr><tr><td>possible_keys</td><td>possible_keys</td><td>可能选择的索引(The possible indexes to choose)</td></tr><tr><td>key</td><td>key</td><td>实际选择的索引(The index actually chosen)</td></tr><tr><td>key_len</td><td>key_length</td><td>选择的索引的长度(The length of the chosen key)</td></tr><tr><td>ref</td><td>ref</td><td>和索引比较的列(The columns compared to the index)</td></tr><tr><td>rows</td><td>rows</td><td>估计被检查的行数(Estimate of rows to be examined)</td></tr><tr><td>filtered</td><td>filtered</td><td>通过表条件过滤的行所占百分比(Percentage of rows filtered by table condition)</td></tr><tr><td>Extra</td><td>None</td><td>额外信息(Additional information)</td></tr></tbody></table><ul><li><p>id（select_id）</p><p>select 标志，在一个查询中一次select的序列号。如果一行参照其他行的合并结果,id的值可以为null。在这种情形下，table列会显示类似<br>$$<br>&lt;unionM,N&gt;<br>$$<br>格式的值来表示该行参照的合并的其他行的id值M,N</p></li><li><p>select_type(none)</p><p>select的类型。 更多见下。</p></li><li><p><code>table</code>(<code>table_name</code>)</p><p>输出行所参照的表的名称，也可以是以下值之一：</p><ul><li>&lt;unionM,N&gt; 该行所参照的和并行的id值M,N。</li><li>&lt;derivedN&gt; 该行所参照的派生表结果的行的id值N。 举个例子 一个派生表可能是来自from子句中的子查询。</li><li>&lt;subqueryN&gt; 该行所参照的物化子查询结果的行的id值N。</li></ul></li><li><p><code>partitions</code>(<code>partitions</code>)</p><p>查询中，记录匹配的分区。非分区表的是，该值为NULL。</p></li><li><p><code>type</code> (<code>access_type</code>)</p><p>连接类型。</p></li><li><p><code>possible_keys</code>(<code>possible_keys</code>)</p><p><code>possible_keys</code>指示mysql可以选择用来寻找表中的行的索引。</p></li><li><p><code>key</code>(<code>key</code>)</p><p>mysql实际选择的索引。</p></li><li><p><code>key_len</code>(<code>key_length</code>)</p><p>由于key的存储格式，一个可以允许NULL的列key的长度比NOT NULL的key的长度大一。</p></li><li><p><code>ref</code>(<code>rows</code>)</p><p>展示哪些行或常量与key列中索引名比较，以便从表中寻找行。</p><p>如果值为func,则使用的值是某个函数的结果。</p><p>要查看是哪个函数，可以在EXPLAIN后面使用SHOW warning来查看扩展的EXPLAIN输出。</p></li><li><p><code>rows</code>(<code>rows</code>)</p><p>指示Mysql认为在执行查询是必须检查的行数。</p><p>对InnoDB表，这个值是个估计值，可能不会经常确切</p></li><li><p><code>filtered</code>(<code>filtered</code>)</p><p>指示一个估计的百分值，这个百分值表示通过表条件筛选出的行站表的总行数的百分比。</p><p>最大值为100，表示没有发生行的筛选。rows展示了需要受检的行数的估计，rows*filtered表示</p><p>与下一个表进行连接运算的行数</p></li><li><p><code>Extra</code>(<code>none</code>)</p><p>mysql解析查询的额外信息</p></li></ul><h2 id="select-type的解释"><a href="#select-type的解释" class="headerlink" title="select_type的解释"></a><code>select_type</code>的解释</h2><table><thead><tr><th>select_type Value</th><th>JSON Name</th><th>Meaning</th></tr></thead><tbody><tr><td><code>SIMPLE</code></td><td><code>None</code></td><td>简单的<code>SELECT</code>(不使用<code>UNION</code> 或 <code>subqueries</code> )<br>Simple <code>SELECT</code> (not using <code>UNION</code> or <code>subqueries</code>)</td></tr><tr><td><code>PRIMARY</code></td><td><code>None</code></td><td>外部查询 <br>Outermost <code>SELECT</code></td></tr><tr><td><code>UNION</code></td><td><code>None</code></td><td><code>UNION</code> 中第二个及之后的<code>SELECT </code><br>Second or later <code>SELECT</code> statement in a <code>UNION</code></td></tr><tr><td><code>DEPENDENT UNION</code></td><td><code>dependent</code> (true)</td><td>UNION 中第二个及之后的SELECT,依赖外查询 <br>Second or later <code>SELECT</code> statement in a <code>UNION</code>, dependent on outer query</td></tr><tr><td><code>UNION RESULT</code></td><td><code>union_result</code></td><td><code>UNION</code> 的结果 <br>Result of a <code>UNION</code>.</td></tr><tr><td><code>SUBQUERY</code></td><td><code>None</code></td><td>子查询中的第一个<code>SELECT</code> <br>First <code>SELECT</code> in <code>subquery</code></td></tr><tr><td><code>DEPENDENT SUBQUERY</code></td><td><code>dependent</code> (true)</td><td>子查询中的第一个<code>SELECT</code>,依赖外查询<br>First <code>SELECT</code> in <code>subquery</code>, dependent on outer query</td></tr><tr><td><code>DERIVED</code></td><td><code>None</code></td><td>派生表 <br>Derived table</td></tr><tr><td><code>DEPENDENT DERIVED</code></td><td><code>dependent</code> (true)</td><td>依赖其他表的派生表<br> Derived table dependent on another table</td></tr><tr><td><code>MATERIALIZED</code></td><td><code>materialized_from_subquery</code></td><td>物化视图查询 <code>Materialized subquery</code></td></tr><tr><td><code>UNCACHEABLE SUBQUERY</code></td><td><code>cacheable</code> (false)</td><td>一个子查询其结果无法被缓存并且对于外查询的每一行字查询结果都需要重新估计 <br>A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td></tr><tr><td><code>UNCACHEABLE UNION</code></td><td><code>cacheable</code> (false)</td><td><code>UNION</code> 中第二个及以上的不可缓存的子查询<br>select The second or later select in a <code>UNION</code> that belongs to an uncacheable subquery (see <code>UNCACHEABLE SUBQUERY</code>)</td></tr></tbody></table><h2 id="连接类型的解释"><a href="#连接类型的解释" class="headerlink" title="连接类型的解释"></a>连接类型的解释</h2><p>查询执行计划中type行展示表是如何连接的。下面从最优到最劣列举连接类型</p><ul><li><p><code>system</code></p><p>只有一行的表(= system table)。 是const连接类型的特殊情形</p></li><li><p><code>const</code></p><p>做多只能匹配到一行的表，并且会在查询执行一开始就读区。因为只有一行，其他优化器可以将这一行中的列中的值视为常量。</p><p>由于只读一次，const表非常快</p><p>当将主键或惟一索引的所有部分与常量值进行比较时，将使用const（点查询）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> a_table <span class="keyword">where</span> primary_key = <span class="string">'a_key_value'</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> a_table <span class="keyword">where</span> candidate_key = <span class="string">'a_candidate_key_value'</span>; //注意码在数据库中是属性集</span><br></pre></td></tr></table></figure></li><li><p><code>eq_ref</code></p><p>对于每个由先前的表得到的组合的行，都需要读取该表的一行。除了<code>system</code> 和 <code>const</code>,这是最可行的连接类型，当索引是<code>PRIMARY KEY</code>或<code>UNIQUE NOT NULL</code>索引并且索引的索引部分都被连接使用时，会使用<code>eq_ref</code>连接类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table,other_table <span class="keyword">WHERE</span> ref_table.key_column=other_table.column;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table,other_table <span class="keyword">WHERE</span> ref_table.key_column_part1=other_table.column</span><br><span class="line"></span><br><span class="line"><span class="keyword">AND</span> ref_table.key_column_part2=<span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>ref</code></p><p>对于每个由先前的表得到的组合的行，匹配所有索引值的行都会读取一次。当使用key的最左前缀或key不是<code>PRIMARY KEY</code>或``UNIQUE`时，连接使用ref类型(换句话说，只要连接不能通过基于key值，找到单个行)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table <span class="keyword">WHERE</span> key_column=expr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table,other_table <span class="keyword">WHERE</span> ref_table.key_column=other_table.column;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table,other_table <span class="keyword">WHERE</span> ref_table.key_column_part1=oth</span><br></pre></td></tr></table></figure></li><li><p><code>fulltext</code></p><p>执行连接时使用了全文索引</p></li><li><p><code>ref_or_null</code></p><p>这个连接类型类似<code>ref</code>，不同的是<code>ref_or_null</code>连接类型会额外搜索一次null值，这种连接类型优化最常用于解决子查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table <span class="keyword">WHERE</span> key_column=expr <span class="keyword">OR</span> key_column <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>自己尝试了一下，当列标记为非空后，不会使用ref_or_null</p></li><li><p><code>index_merge</code></p><p>此连接类型指示使用索引合并优化。在本例中，输出行中的key列包含所使用的索引列表，而key_len包含所使用索引的最长键部分列表。</p></li><li><p><code>unique_subquery</code></p><p>这种类型在如下格式的一些in子查询中替换<code>eq_ref</code>:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value IN (<span class="keyword">SELECT</span> primary_key <span class="keyword">FROM</span> single_table <span class="keyword">WHERE</span> some_expr)</span><br></pre></td></tr></table></figure><p><code>unique_subquery</code>只是为了更好的性能替换了子查询的索引搜索方法</p></li><li><p><code>index_subquery</code></p><p><code>index_subquery</code>类似于<code>unique_subquery</code>。替换 in 子查询，但是符合以下格式的子查询中的非唯一索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value IN (<span class="keyword">SELECT</span> key_column <span class="keyword">FROM</span> single_table <span class="keyword">WHERE</span> some_expr)</span><br></pre></td></tr></table></figure></li><li><p><code>range</code></p><p>只有给定范围内的行被检索,使用索引去选择行，此时<code>key</code>中显示使用的索引<code>key_len</code>显示已使用的最长的key部分。<code>ref</code>显示NULL。</p><p>当使用=、&lt;&gt;、&gt;、&gt;=、&lt;、&lt;=、is NULL、&lt;=&gt;、BETWEEN、LIKE或IN()操作符将键列与常量进行比较时，可以使用range。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> key_column = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> key_column <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> key_column <span class="keyword">IN</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> key_part1 = <span class="number">10</span> <span class="keyword">AND</span> key_part2 <span class="keyword">IN</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>index</code></p><p>这种类型除了索引树被扫描之外类似于<code>ALL</code>。以两种形式发生:</p><ul><li>如在在这个索引在此查询中时覆盖索引并且能用于满足所有要求的数据，只有索引树被扫描。<code>Extra</code>列会显示<code>Using index</code>。由于索引数据大小通常小于表数据，仅扫描索引树通常比<code>ALL</code>快。</li><li>一次全表扫描执行时使用索引并以索引序来读取数据，<code>Using index</code> 不会出现在<code>Extra</code> 行中。</li></ul></li><li><p><code>ALL</code></p><p>对于每个由先前的表得到的组合的行，都会执行全表扫描。如果第一个表没有被标记为<code>const</code>通常不是很好，并且在所有的其他场景下，都非常糟糕。我们可以通过添加索引来避免<code>ALL</code></p></li></ul><h2 id="Extra信息"><a href="#Extra信息" class="headerlink" title="Extra信息"></a><code>Extra</code>信息</h2><p>​    详见官方文档,随着遇到的情况，会更新一些内容</p><p>##Summary</p><p>###理论和实际</p><p>在<code>查询处理(一)</code>中，抽象的表达了高级数据库查询语言有数据库解析翻译，优化，执行最终返回数据的过程，并大致的对什么是查询执行计划做了一个简单的解释</p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 查询处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo_FAQ</title>
      <link href="/sunshine-carroll.github.io/2020/08/31/hexo-FAQ/"/>
      <url>/sunshine-carroll.github.io/2020/08/31/hexo-FAQ/</url>
      
        <content type="html"><![CDATA[<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li>hexo 如何连接站内博客</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[link_name](&#123;% post_link artical_filename artical_title(可选) %&#125;)</span><br></pre></td></tr></table></figure><p>中文乱码问题</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查询处理(一)</title>
      <link href="/sunshine-carroll.github.io/2020/08/31/%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86(%E4%B8%80)/"/>
      <url>/sunshine-carroll.github.io/2020/08/31/%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h2 id="查询处理简介"><a href="#查询处理简介" class="headerlink" title="查询处理简介"></a>查询处理简介</h2><p><code>查询处理</code>是从数据库提取数据时涉及的一系列活动。将高层数据库语言表示的查询语句翻译成能在文件系统物理层上使用的表达式。</p><p>步骤如图所示</p><p><img src="/sunshine-carroll.github.io/2020/08/31/%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86(%E4%B8%80)/steps-in-qyerp-processing.png" alt="steps-in-qyerp-processing"></p><ol><li>首先语法分析器和翻译器将一条高层数据库语言表达的查询语句转化为关系代数表达式。</li><li>优化器使用得到的关系代数表达式以及有关数据的统计生成查询执行计划。</li><li>执行引起根据查询执行计划到存储的数据中找寻并返回执行结构。</li></ol><p>简单的说就是<code>语法分析和翻译</code>→<code>优化</code> → <code>执行</code></p><p>##查询执行计划</p><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li><code>计算原语(evaluation primitive)</code> : 加了如何执行注释的关系代数运算</li><li><code>查询执行计划(query-execution plan)</code>用于执行一个查询的原语操作序列</li></ul><h2 id="小例子"><a href="#小例子" class="headerlink" title="小例子"></a>小例子</h2><p>假设有关系 order(id,order_time,order_amount)</p><p>我们想找到大于3000的order_amount</p><p>SQL语言表示: select order_amount from order where order_amount &gt; 3000</p><p>关系代数表示可以翻译成先选择再投影或先投影在选择:<br>$$<br>\begin{align}<br>\Pi_{order_amount}(\sigma_{order_amount &gt; 3000}(order)) \tag 1\<br>\sigma_{order_amount &gt; 3000}(\Pi_{order_amount}(order)) \tag 2\<br>\end{align}<br>$$<br>选关系代数表达式(1) 表示一下查询执行计划</p><ul><li>$\Pi_{order_amount}$</li><li>$\sigma_{order_amount &gt; 3000}$ ； 使用索引</li><li>order</li></ul>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 查询处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关系代数</title>
      <link href="/sunshine-carroll.github.io/2020/08/28/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/"/>
      <url>/sunshine-carroll.github.io/2020/08/28/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><h3 id="选择运算-the-select-operation"><a href="#选择运算-the-select-operation" class="headerlink" title="选择运算(the select operation)"></a>选择运算(the select operation)</h3><p>​    假设有关系r，r的关系模式为R，P是R的命题函数 ，选择运算选取r中满足命题函数P的元组记为<br>$$<br>\sigma_P (r)<br>$$</p><h3 id="投影运算-the-project-operation"><a href="#投影运算-the-project-operation" class="headerlink" title="投影运算(the project operation)"></a>投影运算(the project operation)</h3><h3 id="集合并运算-the-union-operation"><a href="#集合并运算-the-union-operation" class="headerlink" title="集合并运算(the union operation)"></a>集合并运算(the union operation)</h3><h3 id="集合差运算-the-set-difference-operation"><a href="#集合差运算-the-set-difference-operation" class="headerlink" title="集合差运算(the set-difference operation)"></a>集合差运算(the set-difference operation)</h3><h3 id="笛卡尔积运算-the-cartesian-product-operation"><a href="#笛卡尔积运算-the-cartesian-product-operation" class="headerlink" title="笛卡尔积运算(the cartesian product operation)"></a>笛卡尔积运算(the cartesian product operation)</h3><p>###关系代数表达式的递归定义</p><blockquote><p>基础步骤: 数据库中的关系是<code>关系代数表达式</code>,常数关系是<code>关系代数表达式</code></p><p>递归步骤：如果 $E_1$,$E_2$ 是<code>关系代数表达式</code>，那么以下表达式是<code>关系代数表达式</code></p><ul><li>$E_1\cup E_2$</li><li>$E_1 - E_2$</li><li>$E_1 \times E_2$</li><li>$\sigma_P (E_1)$ P是$E_1$中的一些属性列表上的断言</li><li>$\Pi_S(E_1)$ S是$E_1$中的一些属性列表</li><li>$\rho_x(E_1)$ $x$是$E_1$的新名称</li></ul></blockquote><h3 id="附加的关系代数表达式"><a href="#附加的关系代数表达式" class="headerlink" title="附加的关系代数表达式"></a>附加的关系代数表达式</h3><h4 id="交集（intersection）"><a href="#交集（intersection）" class="headerlink" title="交集（intersection）"></a>交集（intersection）</h4><p>​    $r \cap s = r - (r-s) $</p><h4 id="自然连接-natural-join"><a href="#自然连接-natural-join" class="headerlink" title="自然连接(natural-join)"></a>自然连接(natural-join)</h4><p>$$<br>r \bowtie s = \Pi_{R\cup S}(\sigma_{r.A_1=s.A_1 \and r.A_2 = s.A_2 \and \cdots \and r.A_n = S.A_n}(r \times s))<br>$$</p><p>​    其中$R \cap S = {A_1,A_2,\cdots A_n}$</p><h4 id="theta连接-theta-join"><a href="#theta连接-theta-join" class="headerlink" title="theta连接(theta-join)"></a>theta连接(theta-join)</h4><p>​        $r \bowtie _ \theta s = \sigma_\theta(r \times s)$<br>        </p><h4 id="外连接-outer-join"><a href="#外连接-outer-join" class="headerlink" title="外连接(outer-join)"></a>外连接(outer-join)</h4><ul><li><p>左外连接(left-outer-join)</p><p>$r ⟕ s = (r \bowtie s)\cup (r - \Pi_R(r \bowtie s) \times{null,null \dots null}$<br>${null,null \dots null}的关系模式为S-R$</p></li><li><p>右外连接(right-outer-join)</p><p>$r ⟖ s = (r \bowtie s)\cup {null,null \dots null} \times (s - \Pi_S(r \bowtie s)$<br>${null,null \dots null}的关系模式为R-S$</p></li><li><p>全外连接(full-outer-join)</p><p>$r ⟗ s = (r \bowtie s)\cup (r - \Pi_R(r \bowtie s) \times{null,null \dots null} \cup {null,null \dots null} \times (s - \Pi_S(r \bowtie s)$<br>$第一个 {null,null \dots null}的关系模式为S-R，第二个 {null,null \dots null}的关系模式为R-S$</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>索引和散列</title>
      <link href="/sunshine-carroll.github.io/2020/08/28/%E7%B4%A2%E5%BC%95%E5%92%8C%E6%95%A3%E5%88%97/"/>
      <url>/sunshine-carroll.github.io/2020/08/28/%E7%B4%A2%E5%BC%95%E5%92%8C%E6%95%A3%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="基本的索引类型"><a href="#基本的索引类型" class="headerlink" title="基本的索引类型"></a>基本的索引类型</h3><ol><li>​    基于值的顺序排序（将实数集的公理推广到对象集合，等价关系，确定相等性和比较的概念相当于java的equals() 和 Comparator,并使用对象上的）</li><li>散列索引</li></ol><h3 id="评价索引方式的几个标准"><a href="#评价索引方式的几个标准" class="headerlink" title="评价索引方式的几个标准"></a>评价索引方式的几个标准</h3><ol><li>访问类型（全表扫描，点查询，范围查询）</li><li>访问时间 （随着规模的变化）</li><li>插入时间</li><li>删除时间</li><li>空间开销</li></ol><p>###B+树索引</p><p>##特点</p><ol><li>在数据插入和删除的情况下任能保持执行效率</li><li>采用平衡树的结构，树根到树叶的每条路径长度都相同</li><li>会增加文件插入和删除的性能开销和空间开销，但是对于更新频率较高的文件来说也是可以接受的</li></ol><hr><p>##B+树索引结构</p><h3 id="叶子结点"><a href="#叶子结点" class="headerlink" title="叶子结点"></a>叶子结点</h3><p>​        许多包含n-1个搜索码值$K_1,K_2,K_3,..,K_n-1$和n个指针$P_1,P_2,…,P_n$。每个结点中的搜索码值排序存放<br>允许叶子结点最小的值的个数为$⎡\frac{n-1}{2}⎤$，最多的值的个数为n-1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;K,P&gt;[n-1]  + P</span><br></pre></td></tr></table></figure><p><img src="/sunshine-carroll.github.io/2020/08/28/%E7%B4%A2%E5%BC%95%E5%92%8C%E6%95%A3%E5%88%97/leaf-of-B+Tree.png" alt="leaf-of-B+Tree"></p><p>example</p><p><img src="/sunshine-carroll.github.io/2020/08/28/%E7%B4%A2%E5%BC%95%E5%92%8C%E6%95%A3%E5%88%97/leaf-of-B+tree-example.png"></p><hr><h3 id="非叶结点"><a href="#非叶结点" class="headerlink" title="非叶结点"></a>非叶结点</h3><p>​    非叶结点的结构和叶子结点相同，但是结点只指向树中的结点，最多包含n个指针，最少包含$⎡\frac{n}{2}⎤$个指针</p><p><img src="/sunshine-carroll.github.io/2020/08/28/%E7%B4%A2%E5%BC%95%E5%92%8C%E6%95%A3%E5%88%97/B+tree-example.png" alt="B+tree-example"></p><hr><h3 id="B-树的查询"><a href="#B-树的查询" class="headerlink" title="B+树的查询"></a>B+树的查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function find(value V)&#123;</span><br><span class="line">set C &#x3D; root node;</span><br><span class="line">while (C is not leaf)&#123;</span><br><span class="line">set i &#x3D; smallest number that V &lt;&#x3D; C.K[i];</span><br><span class="line">if(i not exist )&#123;</span><br><span class="line">set P[m] &#x3D; last non-null pointer of the node C;</span><br><span class="line">set C &#x3D; C.P[m];</span><br><span class="line">&#125;else&#123;</span><br><span class="line">if(V &#x3D; C.K[i])&#123;</span><br><span class="line">set &#x3D; C.P[i+1];</span><br><span class="line">&#125;else&#123;</span><br><span class="line">set &#x3D; C.P[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">set i &#x3D; least value such that K[i] &#x3D; V</span><br><span class="line">if(i exist)</span><br><span class="line">return (C,i)</span><br><span class="line">else return null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">procedure printAll(value V)&#123;</span><br><span class="line">set done &#x3D; false;</span><br><span class="line">set (L,i) &#x3D; find(V);</span><br><span class="line">if(L,i) &#x3D;&#x3D; null return;</span><br><span class="line">while(done or L &#x3D;&#x3D; null)&#123;</span><br><span class="line">while(i &gt; number of keys in L or L.K[i]&gt;V)&#123;</span><br><span class="line">print L.P[i];</span><br><span class="line">set i &#x3D; i+1;</span><br><span class="line">&#125;</span><br><span class="line">if(i &gt; number of keys in L)</span><br><span class="line">L &#x3D; L.P[n];</span><br><span class="line">else</span><br><span class="line">set done &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-树的更新"><a href="#B-树的更新" class="headerlink" title="B+树的更新"></a>B+树的更新</h3><h2 id="多玛访问"><a href="#多玛访问" class="headerlink" title="多玛访问"></a>多玛访问</h2><h3 id="多个单码索引"><a href="#多个单码索引" class="headerlink" title="多个单码索引"></a>多个单码索引</h3><p>假设有关系<br>$$<br>instrucor(id,name,dept_name,salary)<br>$$</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">ID</span> <span class="keyword">from</span> instructor <span class="keyword">where</span> dept_name = <span class="string">'Finance'</span> <span class="keyword">and</span> salary = <span class="number">80000</span></span><br></pre></td></tr></table></figure><p>处理这个查询的方式</p><ol><li>利用dept_name 索引  找出金融系的教员，从这些记录中在找出工资等于 80000 的教员</li><li>利用salary 索引  找出工资等于 8000 的教员，从这些记录中找出金融系的教员</li><li>分别使用两个索引找出满足条件的教员，然后在取交集</li></ol><p>导致出现糟糕情况的情型</p><ol><li><p>金融系的记录太多</p></li><li><p>工资为80000的教员太多</p></li><li><p>但是金融系中工资为80000的特别少</p><p>为了的到很小的一个结果，必须扫描大量记录</p></li></ol><h3 id="多玛索引"><a href="#多玛索引" class="headerlink" title="多玛索引"></a>多玛索引</h3><h2 id="静态散列"><a href="#静态散列" class="headerlink" title="静态散列"></a>静态散列</h2><h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p>$$<br>bucket = hashing(key)<br>$$</p><h3 id="理想的散列函数分布特性"><a href="#理想的散列函数分布特性" class="headerlink" title="理想的散列函数分布特性"></a>理想的散列函数分布特性</h3><ol><li>分布均匀  从所有可能的搜索码值的集合中应该为每个桶分配相同数量的搜索码值</li><li>分布随机 不管搜索码值的分布实际是什么样的（指数分布,均匀分布，正态分布…),每个桶分配到的搜索码值数应该相同</li></ol><h3 id="桶溢出处理"><a href="#桶溢出处理" class="headerlink" title="桶溢出处理"></a>桶溢出处理</h3><p>导致溢出的原因</p><ol><li>桶不足  $n_b &gt; \frac{n_r}{n_f}$</li><li>偏斜.  多个记录具有相同搜索码，散列函数分布不均</li></ol><p>处理方式</p><p>溢出桶（适合数据库）</p><p>线性探测函数（适合编译器，和汇编器的符号表）</p><h2 id="动态散列"><a href="#动态散列" class="headerlink" title="动态散列"></a>动态散列</h2><h3 id="🛠相同类似原理的其他工具"><a href="#🛠相同类似原理的其他工具" class="headerlink" title="🛠相同类似原理的其他工具"></a>🛠相同类似原理的其他工具</h3><ol><li>redis 字典（映射，map）的实现(有个渐进再散列)</li><li>HashMap&lt;K,V&gt;（java 8 开始用了红黑树）</li></ol><p>##位图索引</p><p>##各种索引技术的比较表</p><table><thead><tr><th align="center"></th><th align="center">索引顺序文件</th><th align="center">B+tree</th><th align="center">散列</th><th align="center">位图</th><th></th></tr></thead><tbody><tr><td align="center">索引类型</td><td align="center">顺序索引</td><td align="center">顺序索引</td><td align="center">散列索引</td><td align="center"></td><td></td></tr><tr><td align="center">访问时间</td><td align="center">比B+tree慢，随着数据的变大，查询性能，和数据顺序扫描变慢</td><td align="center">随着数据插入和删除依旧能查询性能</td><td align="center"></td><td align="center"></td><td></td></tr><tr><td align="center">插入时间</td><td align="center">链表的插入</td><td align="center">维护B+tree结构的额外时间，结点的分离和合并</td><td align="center"></td><td align="center"></td><td></td></tr><tr><td align="center">删除时间</td><td align="center">链表的删除</td><td align="center">维护B+tree结构的额外时间，结点的分离和合并</td><td align="center"></td><td align="center"></td><td></td></tr><tr><td align="center">空间开销</td><td align="center">比B+tree 少</td><td align="center">空间开销较大</td><td align="center"></td><td align="center"></td><td></td></tr><tr><td align="center">适合的场景</td><td align="center">点查询，范围查询</td><td align="center">点查询，范围查询</td><td align="center">点查询</td><td align="center">多码上的点查询</td><td></td></tr><tr><td align="center">不适合场景</td><td align="center"></td><td align="center"></td><td align="center">范围查询</td><td align="center"></td><td></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Semantic Versioning</title>
      <link href="/sunshine-carroll.github.io/2020/07/29/Semantic-Versioning/"/>
      <url>/sunshine-carroll.github.io/2020/07/29/Semantic-Versioning/</url>
      
        <content type="html"><![CDATA[<p>转自<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">https://semver.org</a></p><h1 id="语义化版本-2-0-0"><a href="#语义化版本-2-0-0" class="headerlink" title="语义化版本 2.0.0"></a>语义化版本 2.0.0</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>版本格式：主版本号.次版本号.修订号，版本号递增规则如下：</p><ol><li>主版本号：当你做了不兼容的 API 修改，</li><li>次版本号：当你做了向下兼容的功能性新增，</li><li>修订号：当你做了向下兼容的问题修正。</li></ol><p>先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在软件管理的领域里存在着被称作“依赖地狱”的死亡之谷，系统规模越大，加入的套件越多，你就越有可能在未来的某一天发现自己已深陷绝望之中。</p><p>在依赖高的系统中发布新版本套件可能很快会成为恶梦。如果依赖关系过高，可能面临版本控制被锁死的风险（必须对每一个相依套件改版才能完成某次升级）。而如果依赖关系过于松散，又将无法避免版本的混乱（假设兼容于未来的多个版本已超出了合理数量）。当你专案的进展因为版本相依被锁死或版本混乱变得不够简便和可靠，就意味着你正处于依赖地狱之中。</p><p>作为这个问题的解决方案之一，我提议用一组简单的规则及条件来约束版本号的配置和增长。这些规则是根据（但不局限于）已经被各种封闭、开放源码软件所广泛使用的惯例所设计。为了让这套理论运作，你必须先有定义好的公共 API。这可以透过文件定义或代码强制要求来实现。无论如何，这套 API 的清楚明了是十分重要的。一旦你定义了公共 API，你就可以透过修改相应的版本号来向大家说明你的修改。考虑使用这样的版本号格式：X.Y.Z（主版本号.次版本号.修订号）修复问题但不影响 API 时，递增修订号；API 保持向下兼容的新增及修改时，递增次版本号；进行不向下兼容的修改时，递增主版本号。</p><p>我称这套系统为“语义化的版本控制”，在这套约定下，版本号及其更新方式包含了相邻版本间的底层代码和修改内容的信息。</p><h2 id="语义化版本控制规范（SemVer）"><a href="#语义化版本控制规范（SemVer）" class="headerlink" title="语义化版本控制规范（SemVer）"></a>语义化版本控制规范（SemVer）</h2><p>以下关键词 MUST、MUST NOT、REQUIRED、SHALL、SHALL NOT、SHOULD、SHOULD NOT、 RECOMMENDED、MAY、OPTIONAL 依照 RFC 2119 的叙述解读。（译注：为了保持语句顺畅， 以下文件遇到的关键词将依照整句语义进行翻译，在此先不进行个别翻译。）</p><ol><li><p>使用语义化版本控制的软件“必须 MUST ”定义公共 API。该 API 可以在代码中被定义或出现于严谨的文件内。无论何种形式都应该力求精确且完整。</p></li><li><p>标准的版本号“必须 MUST ”采用 XYZ 的格式，其中 X、Y 和 Z 为非负的整数，且“禁止 MUST NOT”在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素“必须 MUST ”以数值来递增。例如：1.9.1 -&gt; 1.10.0 -&gt; 1.11.0。</p></li><li><p>标记版本号的软件发行后，“禁止 MUST NOT ”改变该版本软件的内容。任何修改都“必须 MUST ”以新版本发行。</p></li><li><p>主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。</p></li><li><p>1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。</p></li><li><p>修订号 Z（x.y.Z <code>|</code> x &gt; 0）“必须 MUST ”在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。</p></li><li><p>次版本号 Y（x.Y.z <code>|</code> x &gt; 0）“必须 MUST ”在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用时也“必须 MUST ”递增。也“可以 MAY ”在内部程序有大量新功能或改进被加入时递增，其中“可以 MAY ”包括修订级别的改变。每当次版本号递增时，修订号“必须 MUST ”归零。</p></li><li><p>主版本号 X（X.y.z <code>|</code> X &gt; 0）“必须 MUST ”在有任何不兼容的修改被加入公共 API 时递增。其中“可以 MAY ”包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号“必须 MUST ”归零。</p></li><li><p>先行版本号“可以 MAY ”被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符号来修饰。标识符号“必须 MUST ”由 ASCII 码的英数字和连接号 [0-9A-Za-z-] 组成，且“禁止 MUST NOT ”留白。数字型的标识符号“禁止 MUST NOT ”在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法达到兼容的需求。范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。</p></li><li><p>版本编译信息“可以 MAY ”被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符号来修饰。标识符号“必须 MUST ”由 ASCII 的英数字和连接号 [0-9A-Za-z-] 组成，且“禁止 MUST NOT ”留白。当判断版本的优先层级时，版本编译信息“可 SHOULD ”被忽略。因此当两个版本只有在版本编译信息有差别时，属于相同的优先层级。范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。</p></li><li><p>版本的优先层级指的是不同版本在排序时如何比较。判断优先层级时，“必须 MUST ”把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译信息不在这份比较的列表中）。由左到右依序比较每个标识符号，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较，例如：1.0.0 &lt; 2.0.0 &lt; 2.1.0 &lt; 2.1.1。当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。例如：1.0.0-alpha &lt; 1.0.0。有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级“必须 MUST ”透过由左到右的每个被句点分隔的标识符号来比较，直到找到一个差异值后决定：只有数字的标识符号以数值高低比较，有字母或连接号时则逐字以 ASCII 的排序来比较。数字的标识符号比非数字的标识符号优先层级低。若开头的标识符号都相同时，栏位比较多的先行版本号优先层级比较高。范例：1.0.0-alpha &lt; 1.0.0-alpha.1 &lt; 1.0.0-alpha.beta &lt; 1.0.0-beta &lt; 1.0.0-beta.2 &lt; 1.0.0-beta.11 &lt; 1.0.0-rc.1 &lt; 1.0.0。</p></li></ol><h2 id="为什么要使用语义化的版本控制？"><a href="#为什么要使用语义化的版本控制？" class="headerlink" title="为什么要使用语义化的版本控制？"></a>为什么要使用语义化的版本控制？</h2><p>这并不是一个新的或者革命性的想法。实际上，你可能已经在做一些近似的事情了。问题在于只是“近似”还不够。如果没有某个正式的规范可循，版本号对于依赖的管理并无实质意义。将上述的想法命名并给予清楚的定义，让你对软件使用者传达意向变得容易。一旦这些意向变得清楚，弹性（但又不会太弹性）的依赖规范就能达成。</p><p>举个简单的例子就可以展示语义化的版本控制如何让依赖地狱成为过去。假设有个名为“救火车”的函式库，它需要另一个名为“梯子”并已经有使用语义化版本控制的套件。当救火车创建时，梯子的版本号为 3.1.0。因为救火车使用了一些版本 3.1.0 所新增的功能， 你可以放心地指定相依于梯子的版本号大等于 3.1.0 但小于 4.0.0。这样，当梯子版本 3.1.1 和 3.2.0 发布时，你可以将直接它们纳入你的套件管理系统，因为它们能与原有相依的软件兼容。</p><p>作为一位负责任的开发者，你理当确保每次套件升级的运作与版本号的表述一致。现实世界是复杂的，我们除了提高警觉外能做的不多。你所能做的就是让语义化的版本控制为你提供一个健全的方式来发行以及升级套件，而无需推出新的相依套件，节省你的时间及烦恼。</p><p>如果你对此认同，希望立即开始使用语义化版本控制，你只需声明你的函式库正在使用它并遵循这些规则就可以了。请在你的 README 文件中保留此页连结，让别人也知道这些规则并从中受益。</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="在-0-y-z-初始开发阶段，我该如何进行版本控制？"><a href="#在-0-y-z-初始开发阶段，我该如何进行版本控制？" class="headerlink" title="在 0.y.z 初始开发阶段，我该如何进行版本控制？"></a>在 0.y.z 初始开发阶段，我该如何进行版本控制？</h3><p>最简单的做法是以 0.1.0 作为你的初始化开发版本，并在后续的每次发行时递增次版本号。</p><h3 id="如何判断发布-1-0-0-版本的时机？"><a href="#如何判断发布-1-0-0-版本的时机？" class="headerlink" title="如何判断发布 1.0.0 版本的时机？"></a>如何判断发布 1.0.0 版本的时机？</h3><p>当你的软件被用于正式环境，它应该已经达到了 1.0.0 版。如果你已经有个稳定的 API 被使用者依赖，也会是 1.0.0 版。如果你很担心向下兼容的问题，也应该算是 1.0.0 版了。</p><h3 id="这不会阻碍快速开发和迭代吗？"><a href="#这不会阻碍快速开发和迭代吗？" class="headerlink" title="这不会阻碍快速开发和迭代吗？"></a>这不会阻碍快速开发和迭代吗？</h3><p>主版本号为零的时候就是为了做快速开发。如果你每天都在改变 API，那么你应该仍在主版本号为零的阶段（0.y.z），或是正在下个主版本的独立开发分支中。</p><h3 id="对于公共-API，若即使是最小但不向下兼容的改变都需要产生新的主版本号，岂不是很快就达到-42-0-0-版？"><a href="#对于公共-API，若即使是最小但不向下兼容的改变都需要产生新的主版本号，岂不是很快就达到-42-0-0-版？" class="headerlink" title="对于公共 API，若即使是最小但不向下兼容的改变都需要产生新的主版本号，岂不是很快就达到 42.0.0 版？"></a>对于公共 API，若即使是最小但不向下兼容的改变都需要产生新的主版本号，岂不是很快就达到 42.0.0 版？</h3><p>这是开发的责任感和前瞻性的问题。不兼容的改变不应该轻易被加入到有许多依赖代码的软件中。升级所付出的代价可能是巨大的。要递增主版本号来发行不兼容的改版，意味着你必须为这些改变所带来的影响深思熟虑，并且评估所涉及的成本及效益比。</p><h3 id="为整个公共-API-写文件太费事了！"><a href="#为整个公共-API-写文件太费事了！" class="headerlink" title="为整个公共 API 写文件太费事了！"></a>为整个公共 API 写文件太费事了！</h3><p>为供他人使用的软件编写适当的文件，是你作为一名专业开发者应尽的职责。保持专案高效一个非常重要的部份是掌控软件的复杂度，如果没有人知道如何使用你的软件或不知道哪些函数的调用是可靠的，要掌控复杂度会是困难的。长远来看，使用语义化版本控制以及对于公共 API 有良好规范的坚持，可以让每个人及每件事都运行顺畅。</p><h3 id="万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？"><a href="#万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？" class="headerlink" title="万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？"></a>万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？</h3><p>一旦发现自己破坏了语义化版本控制的规范，就要修正这个问题，并发行一个新的次版本号来更正这个问题并且恢复向下兼容。即使是这种情况，也不能去修改已发行的版本。可以的话，将有问题的版本号记录到文件中，告诉使用者问题所在，让他们能够意识到这是有问题的版本。</p><h3 id="如果我更新了自己的依赖但没有改变公共-API-该怎么办？"><a href="#如果我更新了自己的依赖但没有改变公共-API-该怎么办？" class="headerlink" title="如果我更新了自己的依赖但没有改变公共 API 该怎么办？"></a>如果我更新了自己的依赖但没有改变公共 API 该怎么办？</h3><p>由于没有影响到公共 API，这可以被认定是兼容的。若某个软件和你的套件有共同依赖，则它会有自己的依赖规范，作者也会告知可能的冲突。要判断改版是属于修订等级或是次版等级，是依据你更新的依赖关系是为了修复问题或是加入新功能。对于后者，我经常会预期伴随着更多的代码，这显然会是一个次版本号级别的递增。</p><h3 id="如果我变更了公共-API-但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中）"><a href="#如果我变更了公共-API-但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中）" class="headerlink" title="如果我变更了公共 API 但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中）"></a>如果我变更了公共 API 但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中）</h3><p>自行做最佳的判断。如果你有庞大的使用者群在依照公共 API 的意图而变更行为后会大受影响，那么最好做一次主版本的发布，即使严格来说这个修复仅是修订等级的发布。记住， 语义化的版本控制就是透过版本号的改变来传达意义。若这些改变对你的使用者是重要的，那就透过版本号来向他们说明。</p><h3 id="我该如何处理即将弃用的功能？"><a href="#我该如何处理即将弃用的功能？" class="headerlink" title="我该如何处理即将弃用的功能？"></a>我该如何处理即将弃用的功能？</h3><p>弃用现存的功能是软件开发中的家常便饭，也通常是向前发展所必须的。当你弃用部份公共 API 时，你应该做两件事：（1）更新你的文件让使用者知道这个改变，（2）在适当的时机将弃用的功能透过新的次版本号发布。在新的主版本完全移除弃用功能前，至少要有一个次版本包含这个弃用信息，这样使用者才能平顺地转移到新版 API。</p><h3 id="语义化版本对于版本的字串长度是否有限制呢？"><a href="#语义化版本对于版本的字串长度是否有限制呢？" class="headerlink" title="语义化版本对于版本的字串长度是否有限制呢？"></a>语义化版本对于版本的字串长度是否有限制呢？</h3><p>没有，请自行做适当的判断。举例来说，长到 255 个字元的版本已过度夸张。再者，特定的系统对于字串长度可能会有他们自己的限制。</p><h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>语义化版本控制的规范是由 Gravatars 创办者兼 GitHub 共同创办者 <a href="http://tom.preston-werner.com/" target="_blank" rel="noopener">Tom Preston-Werner</a> 所建立。</p><p>如果您有任何建议，请到 <a href="https://github.com/mojombo/semver/issues" target="_blank" rel="noopener">GitHub 上提出您的问题</a>。</p><h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>创用 CC 姓名标示 3.0 Unported 授权条款 <a href="http://creativecommons.org/licenses/by/3.0/" target="_blank" rel="noopener">http://creativecommons.org/licenses/by/3.0/</a></p><hr><hr><h1 id="非转载部分"><a href="#非转载部分" class="headerlink" title="非转载部分"></a>非转载部分</h1><p><img src="/sunshine-carroll.github.io/2020/07/29/Semantic-Versioning/%E7%89%88%E6%9C%AC%E5%8F%98%E5%8C%96.png" alt="版本变化"></p><p>###规范化 git commit message </p><p>git commit message 能够帮助git用户在提交更新时描述更新的内容，随着项目的推进，提交的记录越来越多，规范化的commit message 格式能够有效的描述版本的变迁记录。可以参考<a href="https://github.com/angular/angular/blob/master/CONTRIBUTING.md#commit" target="_blank" rel="noopener">Angular的提交规范</a>,<code>Intelij Idea </code>有插件支持提交模版的使用，包括但不限于</p><ul><li><a href="https://plugins.jetbrains.com/plugin/10100-git-commit-message-plugin/" target="_blank" rel="noopener">git commit message plugin</a></li><li><a href="https://plugins.jetbrains.com/plugin/13477-git-commit-message-helper/" target="_blank" rel="noopener">git commit message helper</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> version control </category>
          
      </categories>
      
      
        <tags>
            
            <tag> version control </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-resources</title>
      <link href="/sunshine-carroll.github.io/2020/07/24/spring-resources/"/>
      <url>/sunshine-carroll.github.io/2020/07/24/spring-resources/</url>
      
        <content type="html"><![CDATA[<p>本文主要参考于Spring官方文档中spring-core resources 部分，加上自身的见解，水平有限，如有不足之处欢迎在下方评论交流。</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>&emsp;&emsp;在编程中，有时需要访问位于不同地方的资源，这些资源可能存在于文件系统，网络环境，或一个web应用等环境中。然而对于使用这些资源的客户端程序员来说，他们更加关心的是资源的内容，资源是否存在等信息，让这些客户端代码去关心如何去获取这些资源只能无端增加客户端代码的复杂性。分散实现核心职责的注意力。spring-core 中的resources部分，体现了Spring对资源的处理方式。</p><h2 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h2><p>&emsp;&emsp;Bruce Eckel 把对象认为是<code>问题空间</code>中的元素及其<code>解空间</code>的表示-We refer to the elements in the <code>problem space</code> and their representations in the <code>solution space</code> as “objects.”面向对象的设计可以从<code>问题空间</code>入手，发现<code>问题空间</code>中存在的概念和元素。</p><p>&emsp;&emsp;资源概念自然是Spring资源处理机制的核心概念之一，Spring <code>Resource</code>接口抽象了资源的行为，这些见名知义的行为(方法)是使用资源的人通常关心的功能。</p><img src="/sunshine-carroll.github.io/2020/07/24/spring-resources/resource.png" alt="resource" style="zoom: 67%;"><h3 id="e-g"><a href="#e-g" class="headerlink" title="e.g"></a>e.g</h3><p>&emsp;&emsp;举个小例子，下面是Spring 加载free marker配置的代码片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">package</span> org.springframework.ui.freemarker;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FreeMarkerConfigurationFactory</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigLocation</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.configLocation = resource;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Configuration <span class="title">createConfiguration</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TemplateException </span>&#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;具有<code>FreeMarkerConfigurationFactory</code>类型的对象只需要设置配置资源的就能够读取资源内容创建配置对象而不用关心配置文件在哪，同时客户端代码也能提供不同形式的配置获取方式并不用关心资源如何被解析</p><h2 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h2><p>&emsp;&emsp;有了资源的抽象后,客户端代码可以不用关心资源的加载，但是资源也不能无中生有。Spring把这份职责交给了<code>ResourceLoader</code></p><img src="/sunshine-carroll.github.io/2020/07/24/spring-resources/resource_loader.png" alt="resource" style="zoom: 67%;"><p>&emsp;&emsp;这个一个典型的工厂方法设计模式,<code>getResource</code>方法的String参数作为一个<code>信使对象</code>，描述了创建资源的信息。这样的工厂方法的案例还有javascript 中 document.createElement(input)。</p><p>&emsp;&emsp;在Spring中所有的ApplicationContext都实现了ResourceLoader接口</p><h3 id="getResource方法参数的格式"><a href="#getResource方法参数的格式" class="headerlink" title="getResource方法参数的格式"></a>getResource方法参数的格式</h3><p>&emsp;&emsp;Spring <code>ResourceLoader</code>的实现，约定getResource方法参数的格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[prefix] &lt;path&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;prefix 表示可选 前缀path 表示必选的路径</p><table><thead><tr><th align="center">prefix</th><th align="center">explanation</th></tr></thead><tbody><tr><td align="center">classpath:</td><td align="center">从类路径加载</td></tr><tr><td align="center">file:</td><td align="center">从文件系统加载</td></tr><tr><td align="center">https:</td><td align="center">从网络中加载</td></tr><tr><td align="center">jar:</td><td align="center">从jar包中加载</td></tr><tr><td align="center">war:</td><td align="center">从tomcat的war包中加载</td></tr><tr><td align="center">(none)</td><td align="center">取决于ApplicationContext的实现</td></tr></tbody></table><h2 id="ResourceLoaderAware"><a href="#ResourceLoaderAware" class="headerlink" title="ResourceLoaderAware"></a>ResourceLoaderAware</h2><p>&emsp;&emsp;Spring提供一系列的名为<code>*Aware</code>的回调接口,使得<code>Bean</code>可以告诉<code>IOC容器</code>需要什么样的依赖,这样容器在创建<code>Bean</code>的时候会尽量满足这些依赖。实现<code>ResourceLoaderAware</code>接口的Bean被容器识别为<code>ResourceLoaderAware</code>类型，并调用setResourceLoader方法，<code>Bean</code>可以通过这个方法访问容器的<code>ResourceLoader</code></p><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><p>&emsp;&emsp;了解一个框架的使用方式和原理最直接有效的方式是去看官方文档，内容全面。可以减少发生不知名错误出现的概率，这些错误可能难以在搜索引擎中找到解决方式。更多内容请看Spring官方提供的文档。包括但不限于:</p><ul><li>Spring 内建的<code>Resource</code>，如<code>URLResource</code>，<code>ClassPathResource</code>等</li><li>不同的<code>ApplicationContext</code>默认加载什么类型的<code>Resource</code></li><li><code>FileSystemApplicationContext</code>和其余<code>ApplicationContext</code>在加载文件系统中绝对路径和相对路径资源的区别</li><li>classpath*: 这样的前缀在什么样的场景使用，并且不应该如何使用</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/core.html#resources" target="_blank" rel="noopener">Spring Reference</a></li><li><a href="https://lingcoder.github.io/OnJava8/#/" target="_blank" rel="noopener">On Java 8</a></li><li>四人帮 设计模式</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring-core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shiro-Architecture</title>
      <link href="/sunshine-carroll.github.io/2020/02/29/Shiro-Architecture/"/>
      <url>/sunshine-carroll.github.io/2020/02/29/Shiro-Architecture/</url>
      
        <content type="html"><![CDATA[<p>翻译自官方文档–<a href="http://shiro.apache.org/architecture.html" target="_blank" rel="noopener">原文地址</a></p><h2 id="Apache-Shiro-Architecture-（Apache-Shiro-架构"><a href="#Apache-Shiro-Architecture-（Apache-Shiro-架构" class="headerlink" title="Apache Shiro Architecture （Apache Shiro 架构)"></a>Apache Shiro Architecture （Apache Shiro 架构)</h2><p>Apache Shiro’s design goals are to simplify application security by being intuitive and easy to use. Shiro’s core design models how most people think about application security - in the context of someone (or something) interacting with an application.  </p><p>Aache Shiro设计的目标是通过直觉化和简易实用设计来简化应用程序安全性开发. Shiro 核心设计模型是 在某人或某物与应用程序交互的场景下，人们对应用程序安全思维方式 </p><hr><p>Software applications are usually designed based on user stories. That is, you’ll often design user interfaces or service APIs based on how a user would (or should) interact with the software. For example, you might say, “If the user interacting with my application is logged in, I will show them a button they can click to view their account information. If they are not logged in, I will show a sign-up button.”</p><p>应用程序软件通常基于用户故事设计。这意味着，你将在设计用户接口或服务API时经常基于一个用户将(或应该)如何和软件交互。举个例子，你可能会说”如果一个用户与我程序交互式已经登入，我将给他们展示一个可以点击查看他们账户信息的按钮，如果他们没有登入，我将展示一个注册按钮”</p><hr><p>This example statement indicates that applications are largely written to satisfy user requirements and needs. Even if the ‘user’ is another software system and not a human being, you still write code to reflect behavior based on who (or what) is currently interacting with your software.</p><p>这个例子的陈述表明一个应用程序通常为了满足用户要求或需求而编写。甚至这个”用户”是其他软件系统而非人类时，你仍需要基于当前与你的软件系统交互的人或物表现出的行为来编写代码</p><hr><p>Shiro reflects these concepts in its own design. By matching what is already intuitive for software developers, Apache Shiro remains intuitive and easy to use in practically any application.</p><p>Shiro 使用自身的设计来表现这些概念。通过联系对于软件开发者来说已有的直观事物，Apache Shiro 几乎可以在任意应用中保留直观性和易用性</p><h2 id="Hign-Level-Overview-高层总览"><a href="#Hign-Level-Overview-高层总览" class="headerlink" title="Hign-Level Overview (高层总览)"></a>Hign-Level Overview (高层总览)</h2><p>At the highest conceptual level, Shiro’s architecture has 3 primary concepts: the <code>Subject</code>, <code>SecurityManager</code> and <code>Realms</code>. The following diagram is a high-level overview of how these components interact, and we’ll cover each concept below:</p><p>在最顶层的概念层中，Shiro 架构有三个主要概念:<code>Subject</code>,<code>SecurityManager</code>和<code>Realms</code>,下图就是这些组件如何交互的一个概念层总览。我们会在下面阐述各个概念</p><p><img src="/sunshine-carroll.github.io/2020/02/29/Shiro-Architecture/ShiroBasicArchitecture.png" alt="ShiroBasicArchitecture"></p><hr><blockquote><ul><li><p><strong>Subject</strong>: As we’ve mentioned in our <a href="http://shiro.apache.org/tutorial.html" target="_blank" rel="noopener">Tutorial</a>, the <code>Subject</code> is essentially a security specific ‘view’ of the the currently executing user. Whereas the word ‘User’ often implies a human being, a <code>Subject</code> can be a person, but it could also represent a 3rd-party service, daemon account, cron job, or anything similar - basically anything that is currently interacting with the software.</p><p><code>Subject</code> instances are all bound to (and require) a <code>SecurityManager</code>. When you interact with a <code>Subject</code>, those interactions translate to subject-specific interactions with the <code>SecurityManager</code>.</p></li><li><p><strong>Subject</strong>: 就像我们在教程中提到的，<code>Subject</code>本质上就是当前执行用户的在安全领域上一个特定的视角，然而”用户”一词通常暗指人类，一个<code>Subject</code>可以是一个人，也可以表示为第三方服务，守护进程账户，定时任务或者任意相似的与当前软件交互的事物</p><p><code>Subject</code>实例都和一个<code>SecurityManager</code>绑定。当你和一个<code>Subject</code>交互时，这些交互就转化为subject-specific 与<code>SecurityManager</code>交互</p></li><li><p><strong>SecurityManager</strong>: The <code>SecurityManager</code> is the heart of Shiro’s architecture and acts as a sort of ’umbrella’ object that coordinates its internal security components that together form an object graph. However, once the SecurityManager and its internal object graph is configured for an application, it is usually left alone and application developers spend almost all of their time with the <code>Subject</code> API.</p><p>We will talk about the <code>SecurityManager</code> in detail later on, but it is important to realize that when you interact with a <code>Subject</code>, it is really the <code>SecurityManager</code> behind the scenes that does all the heavy lifting for any <code>Subject</code> security operation. This is reflected in the basic flow diagram above.</p></li><li><p><strong>SecurityManager</strong>: <code>SecurityManager</code> 是Shiro框架的核心并扮演像是一个协调内部组合成一副对象图景的安全组件的”保护伞”角色。 不管怎样，当<code>SecurityManager</code>和其内部的对象图景配置完成后,通常可以不管他 ，应用程序开发大部分时候都花在和<code>Subject</code> 的交互上。</p><p>我们稍后会讨论<code>SecurityManager</code>的细节，但是，当你和<code>Subject</code>交互的时候，意识到在幕后<code>SecurityManager</code> 为任人一个<code>Subject</code>的安全操作做了所有的艰难操作.这也反应在上面的基本流程图上。</p></li><li><p><strong>Realms</strong>: Realms act as the ‘bridge’ or ‘connector’ between Shiro and your application’s security data. When it comes time to actually interact with security-related data like user accounts to perform authentication (login) and authorization (access control), Shiro looks up many of these things from one or more Realms configured for an application.</p><p>In this sense a Realm is essentially a security-specific <a href="https://en.wikipedia.org/wiki/Data_access_object" target="_blank" rel="noopener">DAO</a>: it encapsulates connection details for data sources and makes the associated data available to Shiro as needed. When configuring Shiro, you must specify at least one Realm to use for authentication and/or authorization. The <code>SecurityManager</code>may be configured with multiple Realms, but at least one is required.</p><p>Shiro provides out-of-the-box Realms to connect to a number of security data sources (aka directories) such as LDAP, relational databases (JDBC), text configuration sources like INI and properties files, and more. You can plug-in your own Realm implementations to represent custom data sources if the default Realms do not meet your needs.</p><p>Like other internal components, the Shiro <code>SecurityManager</code> manages how Realms are used to acquire security and identity data to be represented as <code>Subject</code> instances.</p></li><li><p><strong>Realms</strong>: Realms 扮演者Shiro 和 你的应用程序的安全数据之间的’桥梁’或者说’连接器’的角色。当到Shrio运行到与安全相关的数据交互的时候，如用户账户去执行 认证(登录)，授权(访问控制)， Shiro 从应用程序配置好的一个或多个Realm中搜寻这些数据</p><p>从这个角度，Realm 本质上是一个特定的安全DAO(Data Access Object):他封装和数据源连接的细节，并且使得相关的数据按Shiro所需的方式被Shiro使用。当配置Shiro时，你必须至少指定一个用户认证和（或）授权的Relam。<code>SecurityManager</code>可能会配置多个领域，但至少需要一个</p><p>Shiro 提供一些开箱即用的Realm去和一些安全数据源建立连接，比如说LDAP(轻量级目录访问协议)，关系型数据库(JDBC)，文本配置源如ini和属性文件等等。如果默认的Realms不满足你的需求，你可以插入你自己的领域实现去表示自定义的数据源</p><p>就像其他的内部组件,Shiro的 <code>SecurityManager</code>管理着如何将 Realms 获取安全和身份数据的表示为<code>Subject</code>实例</p></li></ul></blockquote><hr><p>##<a href="http://shiro.apache.org/architecture.html#detailed-architecture" target="_blank" rel="noopener">Detailed Architecture</a>(详细的架构)</p><p>The following diagram shows Shiro’s core architectural concepts followed by short summaries of each:</p><p>下面展示了Shiro的核心架构概念，并为每一个概念有一个简短的总结</p><p><img src="/sunshine-carroll.github.io/2020/02/29/Shiro-Architecture/ShiroArchitecture.png" alt="ShiroArchitecture"></p><blockquote><ul><li><p><strong>Subject</strong> (<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/subject/Subject.html" target="_blank" rel="noopener"><code>org.apache.shiro.subject.Subject</code></a>)<br>A security-specific ‘view’ of the entity (user, 3rd-party service, cron job, etc) currently interacting with the software.</p></li><li><p><strong>Subject</strong> (<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/subject/Subject.html" target="_blank" rel="noopener"><code>org.apache.shiro.subject.Subject</code></a>)</p><p>当前与软件交互的实体(用户，第三方服务，定时任务等等)的一个特定的安全’视图’</p></li><li><p><strong>SecurityManager</strong> (<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/mgt/SecurityManager.html" target="_blank" rel="noopener">org.apache.shiro.mgt.SecurityManager</a>)<br>As mentioned above, the <code>SecurityManager</code> is the heart of Shiro’s architecture. It is mostly an ‘umbrella’ object that coordinates its managed components to ensure they work smoothly together. It also manages Shiro’s view of every application user, so it knows how to perform security operations per user.</p></li><li><p><strong>SecurityManager</strong> (<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/mgt/SecurityManager.html" target="_blank" rel="noopener">org.apache.shiro.mgt.SecurityManager</a>)</p><p>如上所述，<code>SecurityManager</code>时Shiro架构的核心.通常是协调受管组件，确保他们一起平稳的工作的’保护伞’,他管理着每一个应用程序用户的视图，因此他知道如何为每一个用户执行安全的操作</p></li><li><p><strong>Authenticator</strong> (<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/Authenticator.html" target="_blank" rel="noopener">org.apache.shiro.authc.Authenticator</a>)<br>The <code>Authenticator</code> is the component that is responsible for executing and reacting to authentication (log-in) attempts by users. When a user tries to log-in, that logic is executed by the <code>Authenticator</code>. The <code>Authenticator</code> knows how to coordinate with one or more <code>Realms</code> that store relevant user/account information. The data obtained from these <code>Realms</code> is used to verify the user’s identity to guarantee the user really is who they say they are.</p></li><li><p><strong>Authenticator</strong> (<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/Authenticator.html" target="_blank" rel="noopener">org.apache.shiro.authc.Authenticator</a>)</p><p><code>Authenticator</code>是以执行和反应用户的认证（登录）为职责的组件。当一个用户试图登录时，这个逻辑就被<code>Authenticator</code>执行。<code>Authenticator</code>知道如何与存储者用户/账户信息的一个或多个<code>Realm</code>协作。由这些<code>Realms</code>维护的数据用于验证用户的身份，保证用户的确是他们所说的那一个</p></li><li><p><strong>Authorizer</strong> (<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/authz/Authorizer.html" target="_blank" rel="noopener">org.apache.shiro.authz.Authorizer</a>)<br>The <code>Authorizer</code> is the component responsible determining users’ access control in the application. It is the mechanism that ultimately says if a user is allowed to do something or not. Like the <code>Authenticator</code>, the <code>Authorizer</code> also knows how to coordinate with multiple back-end data sources to access role and permission information. The <code>Authorizer</code> uses this information to determine exactly if a user is allowed to perform a given action.</p></li><li><p><code>Authorizer</code>是对确定应用程序中用户的访问控制负责的组件。这个机制最终判断一个用户允许或不允许做一些事。就像<code>Authenticator</code>，<code>Authorizer</code> 知道如何使用多个后台数据源企业访问角色和权限信息。<code>Authorizer</code>使用这些数据去正确的确定一个用户是否允许执行一个给定的行为</p></li><li><p><strong>SessionManager</strong> (<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/session/mgt/SessionManager.html" target="_blank" rel="noopener">org.apache.shiro.session.mgt.SessionManager</a>)<br>The <code>SessionManager</code> knows how to create and manage user <code>Session</code> lifecycles to provide a robust Session experience for users in all environments. This is a unique feature in the world of security frameworks - Shiro has the ability to natively manage user Sessions in any environment, even if there is no Web/Servlet or EJB container available. By default, Shiro will use an existing session mechanism if available, (e.g. Servlet Container), but if there isn’t one, such as in a standalone application or non-web environment, it will use its built-in enterprise session management to offer the same programming experience. The <code>SessionDAO</code> exists to allow any datasource to be used to persist sessions.</p></li><li><p><code>SessionManager</code>知道如何创建和管理用户<code>Session</code>的生命周期并在任何环境下提供给用户一个健壮的会话体验。在安全框架的世界中这是个独特的特性–即使不在Web/Servlet或EJB容器中，Shiro天然的有在任何环境下管理用户会话的能力。如果有可以使用的会话机制(如Servlet Container)，Shiro默认会使用它,但是如果没有，就像独立的应用程序或非web环境下，他会使用他内建的企业级会话管理以提供相同的编程体验。<code>SessionDAO</code>为允许任何用于持久化会话的数据源而存在</p></li><li><p><strong>CacheManager</strong> (<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/cache/CacheManager.html" target="_blank" rel="noopener">org.apache.shiro.cache.CacheManager</a>)<br>The <code>CacheManager</code> creates and manages <code>Cache</code> instance lifecycles used by other Shiro components. Because Shiro can access many back-end data sources for authentication, authorization and session management, caching has always been a first-class  feature in the framework to improve performance while using these data sources. Any of the modern open-source and/or enterprise caching products can be plugged in to Shiro to provide a fast and efficient user-experience.</p></li><li><p><strong>CacheManager</strong> (<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/cache/CacheManager.html" target="_blank" rel="noopener">org.apache.shiro.cache.CacheManager</a>)</p><p><code>CacheManager</code>创建和管理被其他Shiro组件使用的缓存实例的生命周期。由于Shiro 能够访问许多用户认证，授权和会话管理的后台数据，在框架中缓存通常是在使用这些数据源时提高性能的一个优秀的特性。任何一个现代的开源和（或）企业级缓存产品能够嵌入到Shiro中以提高快且高效的用户体验</p></li><li><p><strong>Cryptography</strong> (<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/crypto/package-summary.html" target="_blank" rel="noopener">org.apache.shiro.crypto.*</a>)<br>Cryptography is a natural addition to an enterprise security framework. Shiro’s <code>crypto</code> package contains easy-to-use and understand representations of crytographic Ciphers, Hashes (aka digests) and different codec implementations. All of the classes in this package are carefully designed to be very easy to use and easy to understand. Anyone who has used Java’s native cryptography support knows it can be a challenging animal to tame. Shiro’s crypto APIs simplify the complicated Java mechanisms and make cryptography easy to use for normal mortal human beings.</p></li><li><p>对于一个企业级安全框架，加密是一个自然而然的功能。Shiro 的<code>crypto</code>包含易于使用和理解的密码学上的加密工具，哈希(众所周知的信息摘要算法 ),和不同的编码解码器实现.在这个包中的所有类，都为易于理解和使用而设计。任何一个用过Java原生的加密支持的人都知道,it can be a challenging animal to tame。Shiro的crypto API 简化这些复杂的Java机制并且让加密功能对正常的普通人来说使用简单。</p></li><li><p><strong>Realms</strong> (<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/realm/Realm.html" target="_blank" rel="noopener">org.apache.shiro.realm.Realm</a>)<br>As mentioned above, Realms act as the ‘bridge’ or ‘connector’ between Shiro and your application’s security data. When it comes time to actually interact with security-related data like user accounts to perform authentication (login) and authorization (access control), Shiro looks up many of these things from one or more Realms configured for an application. You can configure as many <code>Realms</code> as you need (usually one per data source) and Shiro will coordinate with them as necessary for both authentication and authorization.</p></li><li><p><strong>Realms</strong> (<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/realm/Realm.html" target="_blank" rel="noopener">org.apache.shiro.realm.Realm</a>)</p><p>如上所述，Realm 扮演的Shiro和你应用程序的安全数据的’桥梁’或’连接器’。当到Shrio运行到与安全相关的数据交互的时候，如用户账户去执行 认证(登录)，授权(访问控制)， Shiro 从应用程序配置好的一个或多个Realm中搜寻这些数据。你可以按你的需要的Realm数来配置Realm(通常每个数据源一个Realm)并且Shiro会按需为认证和授权协调他们</p></li></ul></blockquote><hr><h2 id="The-SecurityManager"><a href="#The-SecurityManager" class="headerlink" title="The SecurityManager"></a>The <code>SecurityManager</code></h2><p>Because Shiro’s API encourages a <code>Subject</code>-centric programming approach, most application developers will rarely, if ever, interact with the <code>SecurityManager</code>directly (framework developers however  sometimes find it useful). Even so, it is still important to know how the <code>SecurityManager</code> functions, especially when configuring one for an application.</p><p>由于 Shiro 的API鼓励一个以<code>Subject</code>为中心的编程方式，大多数应用程序开发者将很少的，与<code>SecurityManager</code>交互(框架开发者却有时认为这是非常有用的)。即使如此，知道<code>SecurityManager</code>的功能依旧是重要的,尤其是在配置一个应用程序的时候</p><h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a><a href="http://shiro.apache.org/architecture.html#design" target="_blank" rel="noopener">Design</a></h2><p>As stated previously, the application’s <code>SecurityManager</code> performs security operations and manages state for <em>all</em> application users. In Shiro’s default <code>SecurityManager</code> implementations, this includes:</p><p>如前所述,应用程序的<code>SecurityManager</code>执行安全操作并且为所有应用程序用户管理状态。在Shiro默认的<code>SecurityManager</code>实现中他包含:</p><ul><li>Authentication  认证</li><li>Authorization  授权</li><li>Session Management 会话管理</li><li>Cache Management 缓存管理</li><li><a href="http://shiro.apache.org/realm.html" target="_blank" rel="noopener">Realm</a> coordination 领域协作</li><li>Event propagation 事件传递</li><li>“Remember Me” Services ‘记住我’ 服务</li><li>Subject creation 创建Subject</li><li>Logout and more. 登出 等等</li></ul><p>But this is a lot of functionality to try to manage in a single component. And, making these things flexible and customizable would be very difficult if everything were lumped into a single implementation class.</p><p>但是有大量的功能尝试放在单个组件中。并且，如果把所有的东西集中在单个实现类中，让这些功能变得灵活和可自定义将会变得非常困难。</p><p>To simplify configuration and enable flexible configuration/pluggability, Shiro’s implementations are all highly modular in design - so modular in fact, that the SecurityManager implementation (and its class-hierarchy) does not do much at all. Instead, the <code>SecurityManager</code> implementations mostly act as a lightweight ‘container’ component, delegating almost all behavior to nested/wrapped components. This ‘wrapper’ design is reflected in the detailed architecture diagram above.</p><p>为了简化配置并能够灵活的配置化/插件化，Shiro的实现在设计上都高度的模块化。事实上由于如此的模块化，<code>SecurityManager</code> 的实现(和他的类层次结构)没有做太多的事情。反而,<code>SecurityManager</code>的实现扮演者轻量级’容器’组件,将大部分行为委托给内嵌的/包装的的组件.这个’包装器’的设计反应在上面的detailed architecture图中</p><p>While the components actually execute the logic, the <code>SecurityManager</code> implementation knows how and when to coordinate the components for the correct behavior.</p><p>当组件实际执行逻辑时，<code>SecurityManager</code>知道如何以及何时协调这些组件来表现正确的行为</p><p>The <code>SecurityManager</code> implementations and the components are also JavaBeans compatible, which allows you (or a configuration mechanism) to easily customize the pluggable components via standard JavaBeans accessor/mutator methods (get<em>/set</em>). This means the Shiro’s architectural modularity can translate into very easy configuration for custom behavior.</p><p><code>SecurityManager</code>的实现和组件都是JavaBeans兼容的,能够允许你(或其他配置机制)通过标准JavaBeans的访问器/修改器方法(get/set)来简洁的自定义这些可插入的组件。这意味着 Shiro的架构模块能否变化非常简易的配置来自定义行为。</p>]]></content>
      
      
      <categories>
          
          <category> Shiro </category>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shiro </tag>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电子书通道</title>
      <link href="/sunshine-carroll.github.io/2020/02/26/%E7%94%B5%E5%AD%90%E4%B9%A6%E9%80%9A%E9%81%93/"/>
      <url>/sunshine-carroll.github.io/2020/02/26/%E7%94%B5%E5%AD%90%E4%B9%A6%E9%80%9A%E9%81%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><ul><li><a href="https://lingcoder.github.io/OnJava8/#/" target="_blank" rel="noopener">On Java 8</a> [^1]</li><li><a href="https://jiapengcai.gitbooks.io/effective-java/" target="_blank" rel="noopener">Effective Java 3</a> </li></ul><p>[^1]: 相当于《Thinking in Java》的第五版，是一本讲语言基础的经典入门书</p>]]></content>
      
      
      <categories>
          
          <category> resources </category>
          
      </categories>
      
      
        <tags>
            
            <tag> resources </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文档通道</title>
      <link href="/sunshine-carroll.github.io/2020/02/26/%E6%96%87%E6%A1%A3%E9%80%9A%E9%81%93/"/>
      <url>/sunshine-carroll.github.io/2020/02/26/%E6%96%87%E6%A1%A3%E9%80%9A%E9%81%93/</url>
      
        <content type="html"><![CDATA[<p>##持久层</p><ul><li><a href="https://mybatis.org/mybatis-3/index.html" target="_blank" rel="noopener"><strong>Mybatis</strong></a>[^1]     <a href="https://mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">中文地址</a></li><li><a href="https://mp.baomidou.com/" target="_blank" rel="noopener"><strong>Mybatis-Plus</strong></a>[^2] 可中英切换</li></ul><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><ul><li><h2 id="项目构建-依赖管理工具"><a href="#项目构建-依赖管理工具" class="headerlink" title="项目构建,依赖管理工具"></a>项目构建,依赖管理工具</h2></li></ul><p>##消息机制</p><p><a href><strong>hexo</strong></a></p><p>[^1]:    MyBatis is a first class persistence framework with support for custom SQL, stored procedures and advanced mappings. MyBatis eliminates almost all of the JDBC code and manual setting of parameters and retrieval of results. MyBatis can use simple XML or Annotations for configuration and map primitives, Map interfaces and Java POJOs (Plain Old Java Objects) to database records.<br>        MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。<br>[^2]:<a href="https://github.com/baomidou/mybatis-plus" target="_blank" rel="noopener">MyBatis-Plus</a>（MP for short）is an powerful enhanced tool for <a href="http://www.mybatis.org/mybatis-3/" target="_blank" rel="noopener">MyBatis</a> , Born To Simplify Development.<br>        MyBatis增强工具,在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><p>::: warning<br><em>here be dragons</em><br>:::</p>]]></content>
      
      
      <categories>
          
          <category> resources </category>
          
      </categories>
      
      
        <tags>
            
            <tag> resources </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鸽巢原理</title>
      <link href="/sunshine-carroll.github.io/2020/02/02/%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86/"/>
      <url>/sunshine-carroll.github.io/2020/02/02/%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="鸽巢原理"><a href="#鸽巢原理" class="headerlink" title="鸽巢原理"></a>鸽巢原理</h2><p>​        如果有$k+1$个或更多的物体放入k个盒子，则至少有一个盒子包含2个或更多的物体。</p><p>证明：<br>            假设没有一个盒子中物体大于1个，那么总物体数≤1×k=k个,和总共有k+1个物体矛盾。</p><hr><h2 id="广义鸽巢原理"><a href="#广义鸽巢原理" class="headerlink" title="广义鸽巢原理"></a>广义鸽巢原理</h2><p>​            如果$N$个物体放入$K$个盒子，那么至少一个盒子包含了$\lceil\frac{N}{K}\rceil$个物体。</p><p>证明：<br>            假如没有一个盒子的物体数超过$\lceil\frac{N}{K}\rceil$,那么总物体数最多有<br>$$<br>k（\lceil\frac{N}{K}\rceil-1）&lt;k（\frac{N}{K}+1-1）=N<br>$$<br>​            这和总物体个数为N互相矛盾</p><hr><h2 id="n-2-1-个任意实数的子序列问题"><a href="#n-2-1-个任意实数的子序列问题" class="headerlink" title="$n^2+1$个任意实数的子序列问题"></a>$n^2+1$个任意实数的子序列问题</h2><p>​        每个由$n^2+1$个不同实数构成的序列都包含着一个长为n+1的严格递增子序列或者严格递减子序列。</p><p>证明：<br>            设$a_1,a_2,\cdots,a_{n^2+1}$是$n^2+1$个不同实数构成的序列，对与序列中的每一个项$a_k$都有一个有序对$(i_k,d_k)$，$i_k$表示从$a_k$开始最长递增子序列的长度,$d_k$表示从$a_k$开始最长递减子序列的长度.<br>            如果每个由$n^2+1$个不同实数构成的序列不存在一个长为n+1的严格递增子序列或者严格递减子序列，那么子序列的长度最多为n，有序对$(i_k,d_k)$有$n^2$种可能，但一共有$n+1$个有序对，那么必定存在$a_s$,$a_j$$s&lt;j$,使得$(i_s,d_s)=(i_j,d_j)$,     因为序列中实数的个数是不同的，所以$a_s&lt;a_j$或$a_s&gt;a_j$<br>            如果$a_s&lt;a_j$,那么从$a_j$开始长度为$i_j$的严格递增子序列中加上$a_s$就构成的从$a_s$开始长度为$i_j+1=i_s+1$的严格递增子序列，这个与从$a_s$开始最长严格递增子序列为$i_s$矛盾。<br>            同理，如果$a_s&gt;a_j$,那么从$a_j$开始长度为$d_j$的严格递减子序列中加上$a_s$就构成的从$a_s$开始长度为$d_j+1=d_s+1$的严格递减子序列，这个与从$a_s$开始最长严格递减子序列为$d_s$矛盾。</p><hr><h2 id="拉姆齐数"><a href="#拉姆齐数" class="headerlink" title="拉姆齐数"></a>拉姆齐数</h2><p>​        拉姆齐数是$R(m,n)$（m,n是大于等于2的正整数）表示，如果一个晚会上两个人两两是朋友或敌人，那么在一个晚会上使得m个人两两是朋友，或n个人两两是敌人所需的最小人数。</p>]]></content>
      
      
      <categories>
          
          <category> discrete mathmatics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> discrete mathmatics </tag>
            
            <tag> counting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计数的基础</title>
      <link href="/sunshine-carroll.github.io/2020/02/01/%E8%AE%A1%E6%95%B0%E7%9A%84%E5%9F%BA%E7%A1%80/"/>
      <url>/sunshine-carroll.github.io/2020/02/01/%E8%AE%A1%E6%95%B0%E7%9A%84%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>##乘积规则</p><p>当一个过程由独立的任务组成时可以使用乘积规则。<br>假设一个过程可以被分解为两个任务。如果完成第一个任务的方式有$n_1$种并且对于每个完成第一个任务的方式，完成第二个任务的方式有$n_2$种，那么完成这个过程有$n_1n_2$种方式。</p><h2 id="THE-PRODUCT-RULE"><a href="#THE-PRODUCT-RULE" class="headerlink" title="THE PRODUCT RULE"></a>THE PRODUCT RULE</h2><p>​        The product rule applies when a procedure is made up of separate tasks.<br>        Suppose that a procedure can be broken down into a sequence of two tasks. If there are $n_1$ ways to do the ﬁrst task and for each of these ways of doing the ﬁrst task, there are $n_2$ ways to do the second task, then there are$n_1n_2$ ways to do the procedure.</p><hr><h2 id="求和法则"><a href="#求和法则" class="headerlink" title="求和法则"></a>求和法则</h2><p>​        如果一个任务能被$n_1$中方式的一种或$n_2$种方式中的一种完成。在$n_1$种方式的集合中没有一个与$n_2$种方式的集合中的元素相同。那么一共有$n_1+n_2$种方式完成这个任务</p><p>##THE SUM RULE</p><p>​        If a task can be done either in one of $n_1$ ways or in one of $n_2$ ways, where none of the set of $n_1$ ways is the same as any of the set of $n_2$ ways, then there are $n_1+n_2$  ways to do the task.</p><hr><h2 id="减法法则-两个集合的容斥原理"><a href="#减法法则-两个集合的容斥原理" class="headerlink" title="减法法则(两个集合的容斥原理)"></a>减法法则(两个集合的容斥原理)</h2><p>​        如果一个任务能用$n_1$种方式或$n_2$种方式的其中一种完成，那么完成这个任务的总方法数为$n_1+n_2$减去这两类方法中相同的方法数</p><h2 id="THE-SUBTRACTION-RULE"><a href="#THE-SUBTRACTION-RULE" class="headerlink" title="THE SUBTRACTION RULE"></a>THE SUBTRACTION RULE</h2><p>If a task can be done in either $n_1$ ways or $n_2$ ways, then the number of ways to do the task is $n_1 + n_2$ minus the number of ways to do the task that are common to the two different ways.<br>$$<br>| A_1∪A_2 | = | A_1 | + | A_2 | − | A_1 ∩ A_2 |<br>$$</p><hr><p>##除法法则</p><p>​        如果一个任务能使用一个有n种方式完成,其中对于每一种方式w，在n种方式中都有d个方式和w方式一样。那么完成这个任务有方法数为$\frac{n}{d}$ </p><p>用集合语言描述:<br>        If the ﬁnite set A is the union of n pairwise disjoint subsets each with d elements, then $n = \frac{| A |}{d}$.<br>        如果一个有限集A是n个互斥的集合的并集,其中每个集合都有d个元素，那么$n = \frac{| A |}{d}$</p><p>用函数语言描述:<br>        If f is a function from A to B where A and B are ﬁnite sets, and that for every value $y ∈ B$ there are exactly d values $x ∈ A$ such that $f (x) = y$ (in which case, we say that f is d-to-one), then$｜B｜= \frac{| A |}{d}$.</p><p>​        如果 f 是一个A到B的函数，A，B都为有限集,对于任意一个$y ∈ B$都有d个$x ∈ A$ 使得$f (x) = y$(在这种情况下，我们称f是d到1的),那么$｜B｜= \frac{| A |}{d}$</p><p>##The Division Rule</p><p>​        There are $\frac{n}{d}$ ways to do a task if it can be done using a procedure that can be carried out in n ways, and for every way w, exactly d of the n ways correspond to way w.</p><h2 id="一些结论"><a href="#一些结论" class="headerlink" title="一些结论"></a>一些结论</h2><ol><li><p>从m元素集合到n元素集合有多少个函数——–$n^m$</p><p>为任意一个元素x属于m指派一个元素y属于n有n种方式，有m个元素要指派，指派第一个有n种方式，在指派第一个元素后指派第二个元素有$n×n$种方式,以此类推一共有$n^m$种方式</p></li><li><p>从m元素集合到n元素集合有多少个一对一函数——–$n(n-1)(n-2)\cdots(n-m+1)$ 其中$m≤n$否则不可能存在一对一函数.</p><p>指派第一个有n种方式，在指派第一个元素后指派第二个元素有$n×(n-1)$种方式,以此类推一共有$n(n-1)(n-2)\cdots(n-m+1)$种方式</p></li><li><p>从m元素集合到n元素集合有多少个部分函数—–$(n+1)^m$<br>$$<br>\begin{pmatrix}<br>m\0<br>\end{pmatrix}×1^mn^0+<br>\begin{pmatrix}<br>m\1<br>\end{pmatrix}<br>×1^{m-1}n^{1}+\dots+<br>\begin{pmatrix}<br>m\m<br>\end{pmatrix}<br>×1^{0}n^{m}=(1+n)^m<br>$$<br>二项式定理如下<br>$$<br>(x+y)^n=\sum_{j=0}^{n}\begin{pmatrix}<br>n\j</p><h1 id="end-pmatrix-x-n-j-y-j"><a href="#end-pmatrix-x-n-j-y-j" class="headerlink" title="\end{pmatrix}x^{n-j}y^j"></a>\end{pmatrix}x^{n-j}y^j</h1><p>\begin{pmatrix}<br>n\0<br>\end{pmatrix}×x^ny^0+<br>\begin{pmatrix}<br>n\1<br>\end{pmatrix}<br>×x^{n-1}y^{1}+\dots+<br>\begin{pmatrix}<br>n\n<br>\end{pmatrix}<br>×x^{0}y^{n}<br>$$<br>当x为1,y为n,n为m时，就是m元素集合到n元素集合部分函数数量的表达式</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> sunshine </category>
          
          <category> discrete mathmatics </category>
          
          <category> counting </category>
          
      </categories>
      
      
        <tags>
            
            <tag> discrete mathematics </tag>
            
            <tag> counting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>良序性，数学归纳法，强归纳法，结构归纳法</title>
      <link href="/sunshine-carroll.github.io/2020/01/29/%E8%89%AF%E5%BA%8F%E6%80%A7%EF%BC%8C%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95%EF%BC%8C%E5%BC%BA%E5%BD%92%E7%BA%B3%E6%B3%95%EF%BC%8C%E7%BB%93%E6%9E%84%E5%BD%92%E7%BA%B3%E6%B3%95/"/>
      <url>/sunshine-carroll.github.io/2020/01/29/%E8%89%AF%E5%BA%8F%E6%80%A7%EF%BC%8C%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95%EF%BC%8C%E5%BC%BA%E5%BD%92%E7%BA%B3%E6%B3%95%EF%BC%8C%E7%BB%93%E6%9E%84%E5%BD%92%E7%BA%B3%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="正整数集合上的公理（Axioms-for-Positive-Integers）"><a href="#正整数集合上的公理（Axioms-for-Positive-Integers）" class="headerlink" title="正整数集合上的公理（Axioms for Positive Integers）"></a>正整数集合上的公理（Axioms for Positive Integers）</h2><ol><li>数1是正整数</li><li>如果n是正整数那么n+1(n的后继也是正整数)</li><li>每个大于1的正整数都是一个正整数的后继</li><li>良序性(The Well-Ordering Property):正整数集合的每个非空子集都有一个最小元</li></ol><h2 id="介绍-introduction"><a href="#介绍-introduction" class="headerlink" title="介绍(introduction)"></a>介绍(introduction)</h2><p>良序性公理–&gt;数学归纳法–&gt;强归纳法–&gt;结构归纳法</p><h3 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h3><p>####描述</p><p>​        很多命题都断言，某个性质对所有有正整数来说都为真。数学归纳法是证明这类命题的一个有效证明方法。首先证明命题对于正整数1成立。然后证明这个命题如果对于一个正整数成立，那么对于下一个正整数也必然成立。这证明方法基于下面这个推理规则。<br>$$<br>∀n∈Z^<em>,\ \ \ \ (P(1)∧(∀k∈Z^</em>,P(k)→P(k+1))  →  ∀nP(n)<br>$$<br>也就是说对于任意正整数n 如果$P(1)$且$∀k∈Z^*,P(k)→P(k+1)$,那么∀nP(n)也成立。</p><h4 id="可以使用使用数学归纳法证明的命题"><a href="#可以使用使用数学归纳法证明的命题" class="headerlink" title="可以使用使用数学归纳法证明的命题"></a>可以使用使用数学归纳法证明的命题</h4><ol><li><p>对于一个无限长的多米诺骨牌，每张多米诺骨牌都直立着，如果第一个多米诺骨牌倒了，并且如果一张多米诺骨牌倒了，下一张多米诺骨牌也会倒，那么所有的多米诺骨牌都会倒。</p></li><li><p>前n个正整数之和为$\frac{n(n-1)}{2}$</p></li><li><p>前n个正奇数之和为$n^2$</p></li><li><p>含有n个元素的有限集的子集个数为$2^n$，n为非负整数(nonpositive integer)</p></li><li><p>假设我们一组讲座，每个讲座都有开始时间和结束时间。假如讲座一旦开始就会持续到结束，两个讲座不能同时进行，一个讲座结束后另一个讲座就开始，演讲厅只有一个，目的是尽可能安排更多的讲座。数学归纳法可以证明每一次选择与已选讲座相容的讲座中，结束时间最早的讲座。就能安排更多的讲座。</p></li><li><p>只要n是一个正整数，则$f(x)=x^n$ 的导数就等于 $nx^{n-1}$，注意命题是微积分中求导法则 $f(x)=x^n$ 的导数为$nx^{n-1}$</p><p>的论域不同，具体看一下高等数学书就知道了</p></li></ol><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>​        在逻辑学中，通过推理规则从前提导出结论的叫演绎推理，寻找结论来支持证据的叫归纳推理，数学证明包括使用了数学归纳法的证明都是演绎推理。这个是术语的冲突。</p><p>​        数学归纳法的基础步骤不一定要从1开始，有时候需要证明对于任意的$n&gt;=b,P(n)$为真,其中n，b是整数，b可以是正数负数或0</p><p>​        有时候数学归纳法不能直接证明一个结论，但是可以证明一个更广的结论，从而得到需要证明的结论，这个方法叫归纳载入</p><h3 id="强归纳法"><a href="#强归纳法" class="headerlink" title="强归纳法"></a>强归纳法</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>​        强归纳法可以使用在直接使用数学归纳法不容易证明的命题上。他的基础步骤和数学归纳法相同，首先证明$P(1)$为真，归纳步骤不同，归纳步骤需要证明对于任意不大于k的正整数 j ,$P(j)$为真，那么$P(k+1)$也为真。表示为逻辑语句就是<br>$$<br>∀n∈Z^<em>,\ \ \ \ (P(1)∧(∀k∈Z^</em>,P(1)∧P(2)∧..∧P(k-1)∧P(k)→P(k+1))  →  ∀nP(n)<br>$$</p><h4 id="强归纳法可以证明的一些命题"><a href="#强归纳法可以证明的一些命题" class="headerlink" title="强归纳法可以证明的一些命题"></a>强归纳法可以证明的一些命题</h4><ol><li>每个正整数都可以写成素数的乘积</li><li>具有n条边的简单多边形能够被三角形化为n-2分三角形，n是大于等于3的整数</li><li>$\sqrt2$是无理数(第一个被发现的无理数就是$\sqrt2$,希帕索斯也因此被丢进了爱琴海)</li><li>任意正整数n都可以写成2的不同次幂的和</li></ol><h4 id="结构归纳法"><a href="#结构归纳法" class="headerlink" title="结构归纳法"></a>结构归纳法</h4><p>##应用</p><p>##正确性证明</p><p>###良序性(The Well-Ordering Property) –&gt; 数学归纳法</p><p>​        先看良序性公理的陈述，正整数集合的每个非空子集都有一个最小元。需要证明的是<br>对于任意正整数n 如果$P(1)$且$∀k∈Z^*,P(k)→P(k+1)$ 能够推出∀nP(n)。</p><hr><p>Proof 1:</p><p>​        首先先注意到有两个前提，第一个是P(1) ≡ T ,</p><p>​                                                    第二个是$∀k∈Z^*,P(k)→P(k+1)$  ≡ T</p><p>​        假设S是使得P(n)为假的值的集合。要证数学归纳法为真$∀n∈Z^<em>,\ \ \ \ (P(1)∧(∀k∈Z^</em>,P(k)→P(k+1))  →  ∀nP(n)$</p><p>可以证明S = ∅ 或者证明 S 非空为假。这里我们证明 S 非空为假。</p><p>​        假设数学归纳法结论为假,也就是说结论的否定为真，即$¬∀nP(n) ≡ T$ </p><p>$¬∀nP(n)$ ≡ ∃n,¬P(n) 也就是说集合S非空。S是正整数集合的子集且非空，那么根据良序性公理，S必定存在最小元，假设该最小元为m，那么m-1 不属于集合S。</p><p>​        因此P(m-1) 为真。</p><p>​        又因为$∀k∈Z^*,P(k)→P(k+1)$为真，则$P(m-1)→P(m)$ ，$P(m) ≡ T$，这与$P(m) ≡ F$ 矛盾，所以$∀nP(n)$</p><hr><p>对于Proof 1 的分析</p><p>​        首先我们希望在对于任意正整数n 如果$P(1)$和$∀k∈Z^*,P(k)→P(k+1)$都为真的前提下，证明$∀nP(n)$也为真.这是直接证明的一个例子。</p><p>​        随后我们发现$∀nP(n)$  等价于S为空,这一步将证明$∀nP(n)$ 转换为证明 S 为空集。为了证明这一点，我们假设S非空，并通过他来得到一个矛盾式(即永远为假的命题)。即P(m)为真并且P(m)为假的矛盾，这是归谬证明法的一个例子。</p><p>后面得到了S非空为假，即S为空为真，因为S为空→$∀nP(n)$，S为空，于是$∀nP(n)$ 为真，这个是假言推理的一个例子。</p><h3 id="数学归纳法–-gt-结构归纳法"><a href="#数学归纳法–-gt-结构归纳法" class="headerlink" title="数学归纳法–&gt;结构归纳法"></a>数学归纳法–&gt;结构归纳法</h3>]]></content>
      
      
      <categories>
          
          <category> sunshine </category>
          
          <category> discrete mathematics </category>
          
          <category> proof </category>
          
      </categories>
      
      
        <tags>
            
            <tag> discrete mathmatics </tag>
            
            <tag> proof </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
